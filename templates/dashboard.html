<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INK | Dashboard</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Staatliches&family=Press+Start+2P&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        /* Base Styles */
        :root {
            --ink-black: #000000;
            --ink-white: #ffffff;
            --ink-gray-light: #f0f0f0;
            --ink-gray-dark: #333333;
            --ink-purple: #7b3eab;
            --ink-blue: #3f51b5;
            --ink-green: #4caf50;
            --ink-amber: #ffc107;
            --ink-orange: #ff5722;
            --ink-red: #f44336;
            --ink-teal: #009688;
            --pixel-size: 8px;
            --menu-width: 250px;
            --menu-collapsed-width: 60px;
            --menu-transition: 0.3s ease;
            --header-height: 80px;
            --skill-star-filled: var(--ink-amber);
            --skill-star-empty: #d0d0d0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #userAvatar {
            display: none;
        }

        body {
            font-family: 'Press Start 2P', monospace;
            background-color: var(--ink-black);
            color: var(--ink-white);
            overflow: hidden;
            height: 100vh;
            image-rendering: pixelated;
            font-size: 0.7rem;
            line-height: 1.5;
        }

        .dashboard {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        /* Header Styles */
        .header {
            display: flex;
            align-items: center;
            padding: 1rem 2rem;
            height: var(--header-height);
            border-bottom: 2px solid var(--ink-white);
            position: relative;
        }

        .ink-title {
            font-family: 'Staatliches', cursive;
            font-size: 3rem;
            letter-spacing: 4px;
            margin-left: 80px;
        }

        .user-info {
            margin-left: auto;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-info img {
            width: 40px;
            height: 40px;
            border-radius: 0;
            object-fit: cover;
            image-rendering: pixelated;
        }

        .logout-btn {
            padding: 0.5rem 1rem;
            background: var(--ink-white);
            color: var(--ink-black);
            text-decoration: none;
            font-size: 0.7rem;
            border-radius: 0;
            /* Pixel-like effect */
            clip-path: polygon(
                0 0, 
                calc(100% - var(--pixel-size)) 0, 
                100% var(--pixel-size), 
                100% 100%, 
                var(--pixel-size) 100%, 
                0 calc(100% - var(--pixel-size))
            );
        }

        /* Dashboard Area */
        .dashboard-area {
            width: 100%;
            height: calc(100vh - var(--header-height));
            position: relative;
            overflow: hidden;
            transition: margin-left var(--menu-transition);
            background-color: var(--ink-black); /* Default background color */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .dashboard-area.menu-revealed {
            margin-left: var(--menu-collapsed-width);
        }

        .dashboard-area.menu-expanded {
            margin-left: var(--menu-width);
        }

        /* Pixel Heart */
        .pixel-heart {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            z-index: 10;
        }

        .heart-pixel {
            width: 100%;
            height: 100%;
            background: var(--ink-white);
            animation: pixel-pulse 2s infinite;
        }

        @keyframes pixel-pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--ink-black);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-size: 1rem;
            font-family: 'Press Start 2P', monospace;
        }

        /* Quick Menu Styles */
        .quick-menu {
            position: fixed;
            top: var(--header-height);
            left: 0;
            width: var(--menu-collapsed-width);
            height: calc(100vh - var(--header-height));
            background-color: var(--ink-black);
            border-right: 2px solid var(--ink-white);
            z-index: 100;
            transition: width var(--menu-transition), transform var(--menu-transition);
            overflow: hidden;
            padding-top: 1rem;
            transform: translateX(-100%);
            font-family: 'Press Start 2P', monospace;
            font-size: 0.7rem;
        }

        .quick-menu.revealed {
            transform: translateX(0);
        }

        .quick-menu.expanded {
            width: var(--menu-width);
        }

        .menu-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: var(--ink-white);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            z-index: 5;
        }

        .menu-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.2);
            cursor: ew-resize;
        }

        .menu-resize-handle:hover {
            background-color: rgba(255, 255, 255, 0.4);
        }

        .menu-section {
            margin-bottom: 1.5rem;
        }

        .menu-section-title {
            padding: 0 1rem;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 0.5rem;
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 0.7rem 1rem;
            color: var(--ink-white);
            text-decoration: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .menu-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .menu-item.active {
            background-color: rgba(255, 255, 255, 0.2);
            border-left: 3px solid var(--ink-white);
        }

        .menu-item-icon {
            margin-right: 1rem;
            font-size: 1rem;
            width: 20px;
            text-align: center;
        }

        .menu-item-text {
            white-space: nowrap;
            opacity: 0;
            transition: opacity var(--menu-transition);
            font-size: 0.6rem;
        }

        .quick-menu.expanded .menu-item-text {
            opacity: 1;
        }

        .menu-footer {
            position: absolute;
            bottom: 1rem;
            left: 0;
            width: 100%;
            padding: 0 1rem;
        }
    </style>
</head>
<style>
    /* Widgets Base Styles */
    .widget {
        position: absolute;
        background-color: var(--ink-white);
        color: var(--ink-black);
        padding: 1rem;
        border-radius: 0;
        box-shadow: 8px 8px 0 rgba(255, 255, 255, 0.1);
        overflow: hidden;
        z-index: 1;
        cursor: move;
        -webkit-user-select: none;
        user-select: none;
        min-width: 200px;
        min-height: 150px;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.7rem;
        
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - var(--pixel-size)) 0, 
            100% var(--pixel-size), 
            100% 100%, 
            var(--pixel-size) 100%, 
            0 calc(100% - var(--pixel-size))
        );
    }

    .widget-active {
        z-index: 10;
        box-shadow: 12px 12px 0 rgba(255, 255, 255, 0.2);
    }

    .widget-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid currentColor;
        margin-bottom: 0.8rem;
        font-size: 0.8rem;
    }

    .widget-title {
        font-weight: bold;
        text-transform: uppercase;
    }

    .widget-content {
        width: 100%;
        height: calc(100% - 30px);
        overflow: auto;
    }

    /* Image Widget */
    .image-widget {
        padding: 0; /* Remove padding for image widget */
        overflow: hidden;
    }

    .image-widget .widget-header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 0.5rem 1rem;
        margin: 0;
        border-bottom: none;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 2;
    }

    .image-widget:hover .widget-header {
        opacity: 1;
    }

    .image-widget .widget-content {
        height: 100%;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
    }

    .image-widget .widget-content img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .image-widget .image-upload-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--ink-black);
        cursor: pointer;
    }

    .image-widget .image-upload-placeholder i {
        font-size: 2rem;
        margin-bottom: 1rem;
    }

    /* Resize handle */
    .resize-handle {
        position: absolute;
        width: 15px;
        height: 15px;
        right: 0;
        bottom: 0;
        cursor: nwse-resize;
        background: currentColor;
        clip-path: polygon(100% 0, 100% 100%, 0 100%);
        opacity: 0.7;
    }

    /* Add Widget Button */
    .add-widget-btn {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        width: 3rem;
        height: 3rem;
        background-color: var(--ink-white);
        color: var(--ink-black);
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        cursor: pointer;
        z-index: 1000;
        
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - var(--pixel-size)) 0, 
            100% var(--pixel-size), 
            100% 100%, 
            var(--pixel-size) 100%, 
            0 calc(100% - var(--pixel-size))
        );
    }

    /* Widget Animation */
    @keyframes widget-appear {
        from {
            opacity: 0;
            transform: scale(0.8);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    .widget {
        animation: widget-appear 0.3s ease-out;
    }

    /* Notifications */
    .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: var(--ink-white);
        color: var(--ink-black);
        padding: 1rem;
        border-radius: 0;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        max-width: 300px;
        font-size: 0.7rem;
        font-family: 'Press Start 2P', monospace;
        animation: notification-slide 0.3s ease-out, notification-fade 5s forwards;
        
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - var(--pixel-size)) 0, 
            100% var(--pixel-size), 
            100% 100%, 
            var(--pixel-size) 100%, 
            0 calc(100% - var(--pixel-size))
        );
    }

    @keyframes notification-slide {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    @keyframes notification-fade {
        0%, 80% { opacity: 1; }
        100% { opacity: 0; }
    }

    /* Specific Widget Styles */
    .profile-widget .widget-content {
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.8rem;
        font-size: 0.65rem;
        line-height: 1.4;
    }

    .profile-info {
        margin-bottom: 0.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }

    /* Enhanced Profile with Skills Rating */
    .skill-rating {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
    }

    .skill-name {
        flex: 1;
        font-weight: 500;
    }

    .skill-stars {
        display: flex;
        gap: 2px;
    }

    .skill-star {
        color: var(--skill-star-empty);
        cursor: pointer;
        font-size: 12px;
    }

    .skill-star.filled {
        color: var(--skill-star-filled);
    }

    .skill-peer-count {
        font-size: 0.6rem;
        margin-left: 8px;
        color: rgba(0, 0, 0, 0.6);
    }

    /* Skills Widget */
    .skills-widget .widget-content {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .skills-container {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }

    .skill-tag {
        background-color: var(--ink-black);
        color: var(--ink-white);
        padding: 0.3rem 0.6rem;
        font-size: 0.6rem;
        border-radius: 0;
        display: inline-block;
        margin-right: 5px;
        margin-bottom: 5px;
        
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 4px) 0, 
            100% 4px, 
            100% 100%, 
            4px 100%, 
            0 calc(100% - 4px)
        );
    }

    /* GitHub Widget */
    .github-widget .widget-content {
        display: grid;
        gap: 0.8rem;
        font-size: 0.65rem;
        line-height: 1.4;
    }

    .github-project {
        padding-bottom: 0.5rem;
        border-bottom: 1px dashed currentColor;
    }

    .github-project:last-child {
        border-bottom: none;
    }

    .github-project-title {
        font-weight: bold;
        margin-bottom: 0.3rem;
    }

    .github-project-description {
        font-size: 0.6rem;
        margin-bottom: 0.5rem;
    }

    .github-project-meta {
        display: flex;
        gap: 1rem;
        font-size: 0.6rem;
    }

    /* Clock & Date Widgets */
    .clock-widget .widget-content, 
    .date-widget .widget-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        font-size: 0.9rem;
        text-align: center;
    }

    /* Notes Widget */
    .notes-widget .widget-content textarea {
        width: 100%;
        height: 100%;
        background: transparent;
        border: none;
        color: inherit;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.65rem;
        resize: none;
        outline: none;
        line-height: 1.4;
    }

    /* Streak Widget */
    .streak-widget .widget-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        gap: 0.8rem;
    }

    .streak-count {
        font-size: 2rem;
        font-weight: bold;
        color: var(--ink-orange);
    }

    .streak-label {
        font-size: 0.65rem;
        margin-bottom: 0.5rem;
    }

    .streak-days {
        display: flex;
        gap: 4px;
        margin-top: 0.5rem;
    }

    .streak-day {
        width: 10px;
        height: 10px;
        background-color: rgba(0, 0, 0, 0.1);
    }

    .streak-day.active {
        background-color: var(--ink-green);
    }

    /* Spotify Widget */
    .spotify-widget .widget-content {
        padding: 0.5rem 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.8rem;
        font-size: 0.65rem;
    }

    .spotify-track-info {
        text-align: center;
        margin-bottom: 0.5rem;
    }

    .spotify-track-image {
        width: 80px;
        height: 80px;
        margin-bottom: 0.5rem;
        object-fit: cover;
        image-rendering: pixelated;
    }

    .spotify-track-name {
        font-weight: bold;
        font-size: 0.7rem;
    }

    .spotify-track-artist {
        font-size: 0.6rem;
        color: rgba(0, 0, 0, 0.7);
    }

    .spotify-progress-bar {
        width: 100%;
        height: 6px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 0;
        overflow: hidden;
        margin: 0.5rem 0;
    }

    .spotify-progress {
        height: 100%;
        background: var(--ink-black);
        width: 0%;
    }

    .spotify-controls {
        display: flex;
        align-items: center;
        gap: 5rem;
        margin-top: 0.5rem;
    }

    .spotify-controls button {
        background: none;
        border: none;
        cursor: pointer;
        color: inherit;
        font-size: 1rem;
    }

    .spotify-connect-btn {
        padding: 0.5rem 1rem;
        background: #1DB954; /* Spotify green */
        color: white;
        border: none;
        font-size: 0.6rem;
        font-weight: bold;
        cursor: pointer;
        margin-top: 1rem;
        font-family: 'Press Start 2P', monospace;
        
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 4px) 0, 
            100% 4px, 
            100% 100%, 
            4px 100%, 
            0 calc(100% - 4px)
        );
    }

    /* Voxel Avatar Styles - NEW */
    .voxel-avatar-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        text-align: center;
    }

    .current-voxel-avatar {
        max-width: 90%;
        max-height: 80%;
        object-fit: contain;
        image-rendering: pixelated;
    }

    .voxel-avatar-name {
        margin-top: 10px;
        font-size: 0.8rem;
    }

    .voxel-avatar-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1rem;
        padding: 1rem;
    }

    .voxel-avatar-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        padding: 0.5rem;
        transition: transform 0.2s;
    }

    .voxel-avatar-item:hover {
        transform: scale(1.05);
        background-color: rgba(0, 0, 0, 0.05);
    }

    .voxel-avatar-option {
        width: 80px;
        height: 80px;
        object-fit: contain;
        image-rendering: pixelated;
    }

    .voxel-avatar-option-name {
        margin-top: 0.5rem;
        font-size: 0.7rem;
        text-align: center;
    }

    /* Bounty Widget */
    .bounty-widget .widget-content {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        font-size: 0.65rem;
    }

    .bounty-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }

    .bounty-stat {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0.5rem;
        background: rgba(0, 0, 0, 0.05);
    }

    .bounty-stat-value {
        font-weight: bold;
        font-size: 1rem;
    }

    .bounty-stat-label {
        font-size: 0.6rem;
    }

    .bounty-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .bounty-item {
        padding: 0.5rem;
        background: rgba(0, 0, 0, 0.05);
        border-left: 3px solid var(--ink-purple);
    }

    .bounty-item-title {
        font-weight: bold;
        margin-bottom: 0.3rem;
    }

    .bounty-item-details {
        display: flex;
        justify-content: space-between;
        font-size: 0.6rem;
    }

    /* Marketplace Widget */
    .marketplace-widget .widget-content {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        font-size: 0.65rem;
    }

    .marketplace-items {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .marketplace-item {
        padding: 0.5rem;
        background: rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
    }

    .marketplace-item-title {
        font-weight: bold;
    }

    .marketplace-item-price {
        display: inline-block;
        background: var(--ink-black);
        color: var(--ink-white);
        padding: 0.2rem 0.5rem;
        font-size: 0.6rem;
        align-self: flex-start;
    }

    /* Study Spot Widget */
    .studyspot-widget .widget-content {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        font-size: 0.65rem;
    }

    .studyspot-map {
        width: 100%;
        height: 150px;
        background: #f0f0f0;
        margin-bottom: 0.5rem;
        position: relative;
    }

    .studyspot-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .studyspot-item {
        padding: 0.5rem;
        background: rgba(0, 0, 0, 0.05);
    }

    .studyspot-name {
        font-weight: bold;
        margin-bottom: 0.2rem;
    }

    .studyspot-details {
        display: flex;
        justify-content: space-between;
        font-size: 0.6rem;
    }

    .studyspot-occupancy {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 0;
        margin-right: 5px;
    }

    .occupancy-low {
        background-color: var(--ink-green);
    }

    .occupancy-medium {
        background-color: var(--ink-amber);
    }

    .occupancy-high {
        background-color: var(--ink-orange);
    }
</style>
<style>
    /* New Feature Styles */
    
    /* Calendar Widget */
    .calendar-widget .widget-content {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.65rem;
        overflow: auto;
    }
    
    .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem 0;
    }
    
    .calendar-title {
        font-weight: bold;
        font-size: 0.7rem;
    }
    
    .calendar-nav {
        display: flex;
        gap: 0.5rem;
    }
    
    .calendar-btn {
        background: var(--ink-black);
        color: var(--ink-white);
        border: none;
        width: 20px;
        height: 20px;
        font-size: 0.6rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 2px) 0, 
            100% 2px, 
            100% 100%, 
            2px 100%, 
            0 calc(100% - 2px)
        );
    }
    
    .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 2px;
    }
    
    .calendar-day-header {
        text-align: center;
        font-size: 0.6rem;
        font-weight: bold;
        padding: 0.3rem 0;
        background: rgba(0, 0, 0, 0.1);
    }
    
    .calendar-day {
        aspect-ratio: 1/1;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.65rem;
        position: relative;
        cursor: pointer;
        background: rgba(0, 0, 0, 0.05);
        transition: background 0.2s;
    }
    
    .calendar-day:hover {
        background: rgba(0, 0, 0, 0.1);
    }
    
    .calendar-day.today {
        background: rgba(123, 62, 171, 0.2);
        font-weight: bold;
    }
    
    .calendar-day.has-events::after {
        content: '';
        position: absolute;
        bottom: 3px;
        width: 4px;
        height: 4px;
        background: var(--ink-purple);
        border-radius: 50%;
    }
    
    .calendar-day.other-month {
        color: rgba(0, 0, 0, 0.3);
    }
    
    .calendar-timetable {
        display: none;
        margin-top: 0.5rem;
    }
    
    .calendar-timetable.active {
        display: block;
    }
    
    .timetable-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem 0;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .timetable-date {
        font-weight: bold;
        font-size: 0.7rem;
    }
    
    .timetable-hours {
        max-height: 150px;
        overflow-y: auto;
    }
    
    .timetable-hour {
        display: flex;
        padding: 0.3rem 0;
        border-bottom: 1px dashed rgba(0, 0, 0, 0.1);
    }
    
    .timetable-time {
        width: 40px;
        font-size: 0.6rem;
        white-space: nowrap;
        margin-right: 0.5rem;
    }
    
    .timetable-event-container {
        flex: 1;
        min-height: 20px;
        position: relative;
        display: flex;
        align-items: center;
    }
    
    .timetable-event {
        background: var(--ink-purple);
        color: white;
        padding: 0.2rem 0.3rem;
        font-size: 0.55rem;
        border-radius: 0;
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 2px) 0, 
            100% 2px, 
            100% 100%, 
            2px 100%, 
            0 calc(100% - 2px)
        );
    }
    
    .timetable-add-btn {
        position: absolute;
        right: 0;
        background: none;
        border: none;
        color: var(--ink-black);
        font-size: 0.7rem;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s;
    }
    
    .timetable-hour:hover .timetable-add-btn {
        opacity: 1;
    }
    
    /* Pomodoro Timer Widget */
    .pomodoro-widget .widget-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        text-align: center;
    }
    
    .pomodoro-timer {
        font-size: 2rem;
        font-weight: bold;
    }
    
    .pomodoro-phase {
        font-size: 0.7rem;
        margin-bottom: 0.5rem;
    }
    
    .pomodoro-controls {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        margin-top: 0.5rem;
    }
    
    .pomodoro-btn {
        background: var(--ink-black);
        color: var(--ink-white);
        border: none;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        padding: 0.5rem 0.8rem;
        cursor: pointer;
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 4px) 0, 
            100% 4px, 
            100% 100%, 
            4px 100%, 
            0 calc(100% - 4px)
        );
    }
    
    .pomodoro-progress {
        width: 100%;
        height: 8px;
        background: rgba(0, 0, 0, 0.1);
        margin-top: 0.5rem;
        position: relative;
    }
    
    .pomodoro-progress-bar {
        height: 100%;
        background: var(--ink-purple);
        width: 0%;
        transition: width 1s linear;
    }
    
    .pomodoro-stats {
        display: flex;
        justify-content: center;
        gap: 1rem;
        font-size: 0.6rem;
        margin-top: 0.5rem;
    }
    
    .pomodoro-stat {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    .pomodoro-stat-value {
        font-weight: bold;
        font-size: 0.8rem;
    }
    
    .pomodoro-settings {
        margin-top: 0.5rem;
        font-size: 0.6rem;
        display: none;
    }
    
    .pomodoro-settings.active {
        display: block;
    }
    
    .pomodoro-input-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.3rem;
    }
    
    .pomodoro-input {
        width: 40px;
        padding: 0.3rem;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        border: 1px solid rgba(0, 0, 0, 0.3);
        text-align: center;
    }
    
    /* Virtual Pet Widget */
    .pet-widget .widget-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        position: relative;
    }
    
    .pet-container {
        width: 100%;
        height: 130px;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    
    .pet-sprite {
        width: 100px;
        height: 100px;
        image-rendering: pixelated;
    }
    
    .pet-status {
        display: flex;
        width: 100%;
        justify-content: space-around;
        margin-top: 0.5rem;
        font-size: 0.6rem;
    }
    
    .pet-stat {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    .pet-stat-label {
        font-size: 0.55rem;
        margin-bottom: 0.2rem;
    }
    
    .pet-stat-bar {
        width: 50px;
        height: 4px;
        background: rgba(0, 0, 0, 0.1);
        overflow: hidden;
    }
    
    .pet-stat-fill {
        height: 100%;
        background: var(--ink-purple);
    }
    
    .pet-actions {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin-top: 0.5rem;
    }
    
    .pet-btn {
        background: var(--ink-black);
        color: var(--ink-white);
        border: none;
        font-size: 0.5rem;
        padding: 0.3rem 0.5rem;
        cursor: pointer;
        font-family: 'Press Start 2P', monospace;
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 3px) 0, 
            100% 3px, 
            100% 100%, 
            3px 100%, 
            0 calc(100% - 3px)
        );
    }
    
    .pet-message {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        border: 1px solid black;
        padding: 0.3rem 0.5rem;
        font-size: 0.6rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        white-space: nowrap;
    }
    
    .pet-message.active {
        opacity: 1;
    }
    
    /* Todo List Widget */
    .todo-widget .widget-content {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.65rem;
        overflow: auto;
    }
    
    .todo-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }
    
    .todo-input {
        flex: 1;
        padding: 0.3rem 0.5rem;
        border: 1px solid rgba(0, 0, 0, 0.2);
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
    }
    
    .todo-add-btn {
        background: var(--ink-black);
        color: var(--ink-white);
        border: none;
        padding: 0.3rem 0.5rem;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        cursor: pointer;
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 3px) 0, 
            100% 3px, 
            100% 100%, 
            3px 100%, 
            0 calc(100% - 3px)
        );
    }
    
    .todo-list {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        max-height: 200px;
        overflow-y: auto;
    }
    
    .todo-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.4rem;
        background: rgba(0, 0, 0, 0.05);
        transition: background 0.2s;
    }
    
    .todo-item:hover {
        background: rgba(0, 0, 0, 0.1);
    }
    
    .todo-checkbox {
        width: 12px;
        height: 12px;
        border: 1px solid black;
        background: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .todo-checkbox.checked {
        background: var(--ink-black);
        color: white;
    }
    
    .todo-checkbox.checked::after {
        content: 'âœ“';
        font-size: 0.6rem;
    }
    
    .todo-text {
        flex: 1;
        font-size: 0.6rem;
        line-height: 1.2;
    }
    
    .todo-text.completed {
        text-decoration: line-through;
        color: rgba(0, 0, 0, 0.5);
    }
    
    .todo-delete {
        background: none;
        border: none;
        color: var(--ink-red);
        cursor: pointer;
        font-size: 0.6rem;
        opacity: 0.5;
        transition: opacity 0.2s;
    }
    
    .todo-item:hover .todo-delete {
        opacity: 1;
    }
    
    .todo-stats {
        display: flex;
        justify-content: space-between;
        font-size: 0.6rem;
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    /* Alarm Widget */
    .alarm-widget .widget-content {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        font-size: 0.65rem;
    }

    /* Compact widget view styles */
    .widget.compact-view .widget-header {
        padding-bottom: 0.3rem;
        margin-bottom: 0.4rem;
    }

    .widget.compact-view .widget-title {
        font-size: 0.7rem;
    }

    .widget.compact-view .widget-content {
        font-size: 0.6rem;
    }

    /* Better compact view styles for Todo widget */
    .todo-widget.compact-view .todo-input {
        font-size: 0.55rem;
        padding: 0.2rem 0.4rem;
    }

    .todo-widget.compact-view .todo-stats {
        display: none; /* Hide stats in compact view */
    }

    .todo-widget.compact-view .todo-header {
        margin-bottom: 0.2rem;
    }

    .todo-widget.compact-view .todo-list {
        max-height: calc(100% - 35px); /* Ensure list takes available space */
    }

    /* Better compact view styles for Pomodoro */
    .pomodoro-widget.compact-view .pomodoro-timer {
        font-size: 1.5rem; /* Keep timer visible but smaller */
    }

    .pomodoro-widget.compact-view .pomodoro-phase {
        display: none; /* Hide phase label */
    }

    .pomodoro-widget.compact-view .pomodoro-progress {
        display: none; /* Hide progress bar */
    }

    .pomodoro-widget.compact-view .pomodoro-stats {
        display: none; /* Hide stats */
    }

    .pomodoro-widget.compact-view .pomodoro-btn {
        padding: 0.3rem 0.5rem;
        font-size: 0.5rem;
    }
    
    .alarm-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
    }
    
    .alarm-time {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
    }
    
    .alarm-status {
        font-size: 0.7rem;
        margin-bottom: 1rem;
    }
    
    .alarm-controls {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .alarm-input-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        justify-content: center;
    }
    
    .alarm-input {
        width: 40px;
        padding: 0.3rem;
        text-align: center;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        border: 1px solid rgba(0, 0, 0, 0.2);
    }
    
    .alarm-btn {
        background: var(--ink-black);
        color: var(--ink-white);
        border: none;
        padding: 0.4rem 0.8rem;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        cursor: pointer;
        margin-top: 0.5rem;
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 3px) 0, 
            100% 3px, 
            100% 100%, 
            3px 100%, 
            0 calc(100% - 3px)
        );
    }
    
    .alarm-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-height: 100px;
        overflow-y: auto;
        margin-top: 0.5rem;
    }
    
    .alarm-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.4rem;
        background: rgba(0, 0, 0, 0.05);
    }
    
    .alarm-item-time {
        font-weight: bold;
    }
    
    .alarm-item-toggle {
        width: 30px;
        height: 15px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        position: relative;
        cursor: pointer;
    }
    
    .alarm-item-toggle.active {
        background: var(--ink-green);
    }
    
    .alarm-item-toggle::after {
        content: '';
        position: absolute;
        width: 11px;
        height: 11px;
        background: white;
        border-radius: 50%;
        top: 2px;
        left: 2px;
        transition: transform 0.2s;
    }
    
    .alarm-item-toggle.active::after {
        transform: translateX(15px);
    }
    
    .alarm-item-delete {
        background: none;
        border: none;
        color: var(--ink-red);
        cursor: pointer;
    }
    
    /* Timer Widget - Separate from Pomodoro */
    .timer-widget .widget-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.8rem;
        text-align: center;
    }
    
    /* Additional styles for timer widget in compact view */
    .timer-widget.compact-view .timer-display {
        font-size: 1rem !important;
        margin: 5px 0 !important;
        display: block !important;
    }

    .timer-widget.compact-view .timer-controls {
        margin-top: 5px;
    }

    .timer-widget.compact-view .timer-setup,
    .timer-widget.compact-view .timer-presets {
        display: none !important;
    }
    
    .timer-display {
        font-size: 1.8rem;
        font-weight: bold;
    }
    
    .timer-controls {
        display: flex;
        gap: 0.5rem;
    }
    
    .timer-btn {
        background: var(--ink-black);
        color: var(--ink-white);
        border: none;
        padding: 0.4rem 0.8rem;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        cursor: pointer;
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - 3px) 0, 
            100% 3px, 
            100% 100%, 
            3px 100%, 
            0 calc(100% - 3px)
        );
    }
    
    .timer-setup {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        margin-top: 0.5rem;
    }
    
    .timer-input {
        width: 40px;
        padding: 0.3rem;
        text-align: center;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        border: 1px solid rgba(0, 0, 0, 0.2);
    }
    
    .timer-label {
        font-size: 0.6rem;
    }
    
    .timer-presets {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        margin-top: 0.5rem;
        justify-content: center;
    }
    
    .timer-preset {
        background: rgba(0, 0, 0, 0.1);
        border: none;
        padding: 0.2rem 0.4rem;
        font-size: 0.55rem;
        cursor: pointer;
        font-family: 'Press Start 2P', monospace;
    }

    /* Image Upload Styles */
    .image-upload-form {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.05);
        border: 2px dashed rgba(0, 0, 0, 0.2);
        cursor: pointer;
    }

    .image-upload-form i {
        font-size: 2rem;
        margin-bottom: 1rem;
        color: rgba(0, 0, 0, 0.5);
    }

    .image-upload-form input[type="file"] {
        display: none;
    }

    .image-upload-label {
        font-size: 0.7rem;
        text-align: center;
        padding: 0.5rem;
        cursor: pointer;
    }

    /* Dashboard Background Settings */
    .background-settings {
        display: none;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--ink-white);
        color: var(--ink-black);
        padding: 1.5rem;
        border-radius: 0;
        z-index: 2000;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.7rem;
        
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - var(--pixel-size)) 0, 
            100% var(--pixel-size), 
            100% 100%, 
            var(--pixel-size) 100%, 
            0 calc(100% - var(--pixel-size))
        );
    }

    .background-settings-title {
        font-size: 0.9rem;
        margin-bottom: 1rem;
        text-align: center;
        font-weight: bold;
    }

    .background-tabs {
        display: flex;
        margin-bottom: 1rem;
        border-bottom: 2px solid rgba(0, 0, 0, 0.1);
    }

    .background-tab {
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-size: 0.65rem;
        opacity: 0.7;
    }

    .background-tab.active {
        opacity: 1;
        border-bottom: 2px solid var(--ink-purple);
        margin-bottom: -2px;
    }

    .background-content {
        display: none;
    }

    .background-content.active {
        display: block;
    }

    .color-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 0.5rem;
        margin-bottom: 1rem;
    }

    .color-option {
        width: 30px;
        height: 30px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        cursor: pointer;
    }

    .color-option:hover {
        transform: scale(1.1);
    }

    .color-option.selected {
        box-shadow: 0 0 0 2px var(--ink-purple);
    }

    .custom-color-input {
        width: 100%;
        margin-top: 0.5rem;
        padding: 0.5rem;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        border: 1px solid rgba(0, 0, 0, 0.2);
    }

    .image-upload-bg {
        margin-top: 1rem;
    }

    .image-preview {
        width: 100%;
        height: 150px;
        background-color: rgba(0, 0, 0, 0.05);
        margin-bottom: 1rem;
        background-size: cover;
        background-position: center;
        border: 1px solid rgba(0, 0, 0, 0.2);
    }

    .background-settings-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-top: 1.5rem;
    }

    .background-btn {
        padding: 0.5rem 1rem;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.6rem;
        border: none;
        cursor: pointer;
    }

    .background-btn.cancel {
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--ink-black);
    }

    .background-btn.apply {
        background-color: var(--ink-purple);
        color: var(--ink-white);
    }

    /* Page context menu */
    .page-context-menu {
        position: fixed;
        background-color: var(--ink-white);
        color: var(--ink-black);
        padding: 0.8rem;
        border-radius: 0;
        z-index: 2000;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.65rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        
        /* Pixel-like effect */
        clip-path: polygon(
            0 0, 
            calc(100% - var(--pixel-size)) 0, 
            100% var(--pixel-size), 
            100% 100%, 
            var(--pixel-size) 100%, 
            0 calc(100% - var(--pixel-size))
        );
        display: none;
    }

    .page-context-menu-option {
        padding: 0.6rem 1rem;
        cursor: pointer;
        white-space: nowrap;
        display: flex;
        align-items: center;
        gap: 0.8rem;
    }

    .page-context-menu-option:hover {
        background-color: rgba(0, 0, 0, 0.05);
    }

    .page-context-menu-option i {
        width: 16px;
        text-align: center;
    }
</style>
<body>
    <!-- Loading screen (will be hidden when page loads) -->
    <div class="loading" id="loadingScreen">Loading your INK dashboard...</div>

    <!-- Main Dashboard Container -->
    <div class="dashboard">
        <!-- Header -->
        <header class="header">
            <div class="pixel-heart" id="pixelHeart"></div>
            <h1 class="ink-title">INK</h1>
            <div class="user-info">
                <img id="userAvatar" src="{{ url_for('static', filename='assets/avatars/default.png') }}" alt="User Avatar">
                <span id="username">{{ user.username }}</span>
                <a href="#" id="menuToggleBtn" class="menu-btn"><i class="fas fa-bars"></i></a>
                <a href="/logout" class="logout-btn" id="logoutBtn">Logout</a>
            </div>
        </header>
        
        <!-- Quick Menu -->
        <nav class="quick-menu" id="quickMenu">
            <button class="menu-toggle" id="collapseMenuBtn">
                <i class="fas fa-chevron-left"></i>
            </button>
            <div class="menu-resize-handle" id="menuResizeHandle"></div>
            
            <div class="menu-section">
                <div class="menu-section-title">Navigation</div>
                <a href="#" class="menu-item active">
                    <span class="menu-item-icon"><i class="fas fa-columns"></i></span>
                    <span class="menu-item-text">Dashboard</span>
                </a>
                <a href="#" class="menu-item" id="editProfileBtn">
                    <span class="menu-item-icon"><i class="fas fa-user-edit"></i></span>
                    <span class="menu-item-text">Edit Profile</span>
                </a>
            </div>
            
            <div class="menu-section">
                <div class="menu-section-title">Features</div>
                <a href="/bounties" class="menu-item">
                    <span class="menu-item-icon"><i class="fas fa-trophy"></i></span>
                    <span class="menu-item-text">Bounties</span>
                </a>
                <a href="/marketplace" class="menu-item">
                    <span class="menu-item-icon"><i class="fas fa-store"></i></span>
                    <span class="menu-item-text">Marketplace</span>
                </a>
                <a href="/studyspots" class="menu-item">
                    <span class="menu-item-icon"><i class="fas fa-map-marker-alt"></i></span>
                    <span class="menu-item-text">Study Spots</span>
                </a>
                <a href="#" class="menu-item">
                    <span class="menu-item-icon"><i class="fas fa-chalkboard-teacher"></i></span>
                    <span class="menu-item-text">Tutoring</span>
                </a>
                <a href="/knowledge-forum" class="menu-item">
                    <span class="menu-item-icon"><i class="fas fa-comments"></i></span>
                    <span class="menu-item-text">Q&A Forums</span>
                </a>
            </div>
            
            <div class="menu-footer">
                <a href="/logout" class="menu-item">
                    <span class="menu-item-icon"><i class="fas fa-sign-out-alt"></i></span>
                    <span class="menu-item-text">Logout</span>
                </a>
            </div>
        </nav>
        <!-- Dashboard Area - Containers will be placed here -->
        <main class="dashboard-area" id="dashboardArea">
            <!-- Containers will be dynamically inserted here -->
        </main>
        
        <!-- Add Widget Button -->
        <button class="add-widget-btn" id="addWidgetBtn">+</button>
        
    </div>
    <!-- Widget Menu Structure (Hidden by default) -->
    <div class="widget-menu" id="widgetMenu">
        <div class="widget-category" data-category="profile">
            <div class="widget-category-header">
                <i class="fas fa-user"></i> Profile & Social
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="widget-category-items">
                <div class="widget-option" data-widget="profile">
                    <i class="fas fa-user-circle"></i> Basic Info
                </div>
                <div class="widget-option" data-widget="skills">
                    <i class="fas fa-code"></i> Skills
                </div>
                <div class="widget-option" data-widget="github">
                    <i class="fab fa-github"></i> GitHub
                </div>
                <div class="widget-option" data-widget="avatar">
                    <i class="fas fa-image"></i> Avatar
                </div>
                <div class="widget-option" data-widget="streak">
                    <i class="fas fa-fire"></i> Streak
                </div>
            </div>
        </div>
        
        <div class="widget-category" data-category="knowledge">
            <div class="widget-category-header">
                <i class="fas fa-graduation-cap"></i> Knowledge & Learning
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="widget-category-items">
                <div class="widget-option" data-widget="bounty">
                    <i class="fas fa-trophy"></i> Bounties
                </div>
                <div class="widget-option" data-widget="qa">
                    <i class="fas fa-question-circle"></i> Q&A Activity
                </div>
                <div class="widget-option" data-widget="study">
                    <i class="fas fa-book"></i> Study Tracker
                </div>
            </div>
        </div>
        
        <div class="widget-category" data-category="economy">
            <div class="widget-category-header">
                <i class="fas fa-coins"></i> Economy & Marketplace
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="widget-category-items">
                <div class="widget-option" data-widget="coins">
                    <i class="fas fa-wallet"></i> Coin Balance
                </div>
                <div class="widget-option" data-widget="marketplace">
                    <i class="fas fa-store"></i> Marketplace
                </div>
                <div class="widget-option" data-widget="transactions">
                    <i class="fas fa-exchange-alt"></i> Transactions
                </div>
            </div>
        </div>
        
        <div class="widget-category" data-category="collaboration">
            <div class="widget-category-header">
                <i class="fas fa-users"></i> Collaboration
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="widget-category-items">
                <div class="widget-option" data-widget="tutoring">
                    <i class="fas fa-chalkboard-teacher"></i> Tutoring
                </div>
                <div class="widget-option" data-widget="messages">
                    <i class="fas fa-comments"></i> Messages
                </div>
                <div class="widget-option" data-widget="studyspot">
                    <i class="fas fa-map-marker-alt"></i> Study Spots
                </div>
            </div>
        </div>
        
        <div class="widget-category" data-category="tools">
            <div class="widget-category-header">
                <i class="fas fa-tools"></i> Tools & Utilities
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="widget-category-items">
                <div class="widget-option" data-widget="clock">
                    <i class="fas fa-clock"></i> Clock
                </div>
                <div class="widget-option" data-widget="date">
                    <i class="fas fa-calendar"></i> Date
                </div>
                <div class="widget-option" data-widget="notes">
                    <i class="fas fa-sticky-note"></i> Notes
                </div>
                <div class="widget-option" data-widget="image">
                    <i class="fas fa-image"></i> Image
                </div>
                <div class="widget-option" data-widget="spotify">
                    <i class="fab fa-spotify"></i> Spotify
                </div>
                <div class="widget-option" data-widget="timer">
                    <i class="fas fa-stopwatch"></i> Timer
                </div>
                <div class="widget-option" data-widget="calendar">
                    <i class="fas fa-calendar-alt"></i> Calendar
                </div>
                <div class="widget-option" data-widget="pomodoro">
                    <i class="fas fa-hourglass-half"></i> Pomodoro Timer
                </div>
                <div class="widget-option" data-widget="pet">
                    <i class="fas fa-cat"></i> Virtual Pet
                </div>
                <div class="widget-option" data-widget="todo">
                    <i class="fas fa-tasks"></i> To-Do List
                </div>
                <div class="widget-option" data-widget="alarm">
                    <i class="fas fa-bell"></i> Alarm
                </div>
            </div>
        </div>
    </div>
    
    <!-- Context Menu (Hidden by default) -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-option" data-action="bg-color">
            <i class="fas fa-fill-drip"></i> Change Background Color
        </div>
        <div class="context-menu-option" data-action="text-color">
            <i class="fas fa-font"></i> Change Text Color
        </div>
        <div class="context-menu-option" data-action="visibility-toggle">
            <i class="fas fa-eye"></i> Toggle Public/Private
        </div>
        <div class="context-menu-option" data-action="resize">
            <i class="fas fa-expand-alt"></i> Toggle Resize Mode
        </div>
        <div class="context-menu-option" data-action="change-function">
            <i class="fas fa-exchange-alt"></i> Change Function
        </div>
        <div class="context-menu-option" data-action="remove">
            <i class="fas fa-trash"></i> Remove Widget
        </div>
    </div>
    
    <!-- Page Context Menu (Hidden by default) -->
    <div class="page-context-menu" id="pageContextMenu">
        <div class="page-context-menu-option" data-action="change-bg">
            <i class="fas fa-fill-drip"></i> Change Background
        </div>
        <div class="page-context-menu-option" data-action="change-all-widgets">
            <i class="fas fa-palette"></i> Change All Widgets Color
        </div>
        <div class="page-context-menu-option" data-action="toggle-all-visibility">
            <i class="fas fa-eye"></i> Make All Widgets Public/Private
        </div>
    </div>
    
    <!-- Color Picker (Hidden by default) -->
    <div class="color-picker" id="colorPicker">
        <div class="color-option" data-color="#ffffff">
            <div class="color-preview" style="background-color: #ffffff;"></div>White
        </div>
        <div class="color-option" data-color="#000000">
            <div class="color-preview" style="background-color: #000000;"></div>Black
        </div>
        <div class="color-option" data-color="#f0f0f0">
            <div class="color-preview" style="background-color: #f0f0f0;"></div>Light Grey
        </div>
        <div class="color-option" data-color="#333333">
            <div class="color-preview" style="background-color: #333333;"></div>Dark Grey
        </div>
        <div class="color-option" data-color="#7b3eab">
            <div class="color-preview" style="background-color: #7b3eab;"></div>Purple
        </div>
        <div class="color-option" data-color="#3f51b5">
            <div class="color-preview" style="background-color: #3f51b5;"></div>Blue
        </div>
        <div class="color-option" data-color="#009688">
            <div class="color-preview" style="background-color: #009688;"></div>Teal
        </div>
        <div class="color-option" data-color="#4caf50">
            <div class="color-preview" style="background-color: #4caf50;"></div>Green
        </div>
        <div class="color-option" data-color="#ffc107">
            <div class="color-preview" style="background-color: #ffc107;"></div>Amber
        </div>
        <div class="color-option" data-color="#ff5722">
            <div class="color-preview" style="background-color: #ff5722;"></div>Deep Orange
        </div>
    </div>

    <!-- Background Settings Modal -->
    <div class="background-settings" id="backgroundSettings">
        <div class="background-settings-title">Dashboard Background</div>
        
        <div class="background-tabs">
            <div class="background-tab active" data-tab="color">Color</div>
            <div class="background-tab" data-tab="image">Image</div>
        </div>
        
        <div class="background-content active" data-content="color">
            <div class="color-grid">
                <div class="color-option selected" data-color="#000000" style="background-color: #000000;"></div>
                <div class="color-option" data-color="#333333" style="background-color: #333333;"></div>
                <div class="color-option" data-color="#7b3eab" style="background-color: #7b3eab;"></div>
                <div class="color-option" data-color="#3f51b5" style="background-color: #3f51b5;"></div>
                <div class="color-option" data-color="#009688" style="background-color: #009688;"></div>
                <div class="color-option" data-color="#4caf50" style="background-color: #4caf50;"></div>
                <div class="color-option" data-color="#ffc107" style="background-color: #ffc107;"></div>
                <div class="color-option" data-color="#ff5722" style="background-color: #ff5722;"></div>
                <div class="color-option" data-color="#f44336" style="background-color: #f44336;"></div>
                <div class="color-option" data-color="#2196f3" style="background-color: #2196f3;"></div>
            </div>
            
            <input type="text" class="custom-color-input" id="customColorInput" placeholder="#000000">
        </div>
        
        <div class="background-content" data-content="image">
            <div class="image-preview" id="bgImagePreview"></div>
            
            <div class="image-upload-bg">
                <label for="bgImageUpload" class="alarm-btn">Choose Image</label>
                <input type="file" id="bgImageUpload" accept="image/*" style="display: none;">
            </div>
        </div>
        
        <div class="background-settings-buttons">
            <button class="background-btn cancel" id="cancelBgSettings">Cancel</button>
            <button class="background-btn apply" id="applyBgSettings">Apply</button>
        </div>
    </div>

    <!-- Widget Color Change Modal -->
    <div class="background-settings" id="widgetColorSettings">
        <div class="background-settings-title">Change All Widgets</div>
        
        <div class="background-tabs">
            <div class="background-tab active" data-tab="widget-bg">Background</div>
            <div class="background-tab" data-tab="widget-text">Text</div>
        </div>
        
        <div class="background-content active" data-content="widget-bg">
            <div class="color-grid">
                <div class="color-option selected" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <div class="color-option" data-color="#f0f0f0" style="background-color: #f0f0f0;"></div>
                <div class="color-option" data-color="#7b3eab" style="background-color: #7b3eab;"></div>
                <div class="color-option" data-color="#3f51b5" style="background-color: #3f51b5;"></div>
                <div class="color-option" data-color="#009688" style="background-color: #009688;"></div>
                <div class="color-option" data-color="#4caf50" style="background-color: #4caf50;"></div>
                <div class="color-option" data-color="#ffc107" style="background-color: #ffc107;"></div>
                <div class="color-option" data-color="#ff5722" style="background-color: #ff5722;"></div>
                <div class="color-option" data-color="#f44336" style="background-color: #f44336;"></div>
                <div class="color-option" data-color="#2196f3" style="background-color: #2196f3;"></div>
            </div>
            
            <input type="text" class="custom-color-input" id="customWidgetBgInput" placeholder="#ffffff">
        </div>
        
        <div class="background-content" data-content="widget-text">
            <div class="color-grid">
                <div class="color-option selected" data-color="#000000" style="background-color: #000000;"></div>
                <div class="color-option" data-color="#333333" style="background-color: #333333;"></div>
                <div class="color-option" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <div class="color-option" data-color="#3f51b5" style="background-color: #3f51b5;"></div>
                <div class="color-option" data-color="#009688" style="background-color: #009688;"></div>
                <div class="color-option" data-color="#4caf50" style="background-color: #4caf50;"></div>
                <div class="color-option" data-color="#ffc107" style="background-color: #ffc107;"></div>
                <div class="color-option" data-color="#ff5722" style="background-color: #ff5722;"></div>
                <div class="color-option" data-color="#f44336" style="background-color: #f44336;"></div>
                <div class="color-option" data-color="#2196f3" style="background-color: #2196f3;"></div>
            </div>
            
            <input type="text" class="custom-color-input" id="customWidgetTextInput" placeholder="#000000">
        </div>
        
        <div class="background-settings-buttons">
            <button class="background-btn cancel" id="cancelWidgetColorSettings">Cancel</button>
            <button class="background-btn apply" id="applyWidgetColorSettings">Apply</button>
        </div>
    </div>

    <!-- Profile Editor Modal (Hidden by default) -->
    <div class="modal" id="profileEditorModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Edit Profile</h2>
                <button class="modal-close" id="closeProfileEditorBtn">&times;</button>
            </div>
            <div class="modal-body">
                <form id="profileEditorForm">
                    <div class="form-group">
                        <label for="profileUsername">Username</label>
                        <input type="text" id="profileUsername" value="">
                    </div>
                    <div class="form-group">
                        <label for="profileUniversity">University</label>
                        <input type="text" id="profileUniversity" value="">
                    </div>
                    <div class="form-group">
                        <label for="profileDepartment">Department</label>
                        <input type="text" id="profileDepartment" value="">
                    </div>
                    <div class="form-group">
                        <label for="profileYear">Year of Study</label>
                        <input type="text" id="profileYear" value="">
                    </div>
                    
                    <div class="form-group">
                        <label>Skills & Ratings</label>
                        <div id="skillRatingsContainer">
                            <!-- Skills will be added dynamically -->
                        </div>
                        <div class="add-skill-row">
                            <input type="text" id="newSkillInput" placeholder="Add a new skill...">
                            <button type="button" id="addSkillBtn">Add</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <button type="submit" class="submit-btn">Save Changes</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Event Editor Modal for Calendar (Hidden by default) -->
    <div class="modal" id="eventEditorModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Add Event</h2>
                <button class="modal-close" id="closeEventEditorBtn">&times;</button>
            </div>
            <div class="modal-body">
                <form id="eventEditorForm">
                    <div class="form-group">
                        <label for="eventTitle">Event Title</label>
                        <input type="text" id="eventTitle" required>
                    </div>
                    <div class="form-group">
                        <label for="eventDate">Date</label>
                        <input type="date" id="eventDate" required>
                    </div>
                    <div class="form-group">
                        <label for="eventTime">Time</label>
                        <input type="time" id="eventTime" required>
                    </div>
                    <div class="form-group">
                        <label for="eventDuration">Duration (minutes)</label>
                        <input type="number" id="eventDuration" min="5" max="1440" value="60">
                    </div>
                    <div class="form-group">
                        <label for="eventColor">Color</label>
                        <select id="eventColor">
                            <option value="#7b3eab">Purple</option>
                            <option value="#3f51b5">Blue</option>
                            <option value="#009688">Teal</option>
                            <option value="#4caf50">Green</option>
                            <option value="#ffc107">Amber</option>
                            <option value="#ff5722">Orange</option>
                            <option value="#f44336">Red</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <button type="submit" class="submit-btn">Save Event</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <style>
        /* Widget Menu Styles */
        .widget-menu {
            position: fixed;
            bottom: 5.5rem;
            right: 2rem;
            background-color: var(--ink-white);
            color: var(--ink-black);
            padding: 0.5rem;
            border-radius: 0;
            display: none;
            z-index: 1000;
            font-size: 0.65rem;
            max-height: 80vh;
            overflow-y: auto;
            font-family: 'Press Start 2P', monospace;
            
            /* Pixel-like effect */
            clip-path: polygon(
                0 0, 
                calc(100% - var(--pixel-size)) 0, 
                100% var(--pixel-size), 
                100% 100%, 
                var(--pixel-size) 100%, 
                0 calc(100% - var(--pixel-size))
            );
        }

        .widget-category {
            margin-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .widget-category:last-child {
            border-bottom: none;
        }

        .widget-category-header {
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 0.7rem;
        }

        .widget-category-header:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .widget-category-items {
            display: none;
            padding-left: 0.5rem;
        }

        .widget-category.active .widget-category-items {
            display: block;
        }

        .widget-category.active .widget-category-header i.fa-chevron-down {
            transform: rotate(180deg);
        }

        .widget-option {
            padding: 0.5rem 1rem;
            cursor: pointer;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.65rem;
        }

        .widget-option:hover {
            background-color: var(--ink-gray-light);
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background-color: var(--ink-white);
            color: var(--ink-black);
            padding: 0.5rem;
            border-radius: 0;
            display: none;
            z-index: 1100;
            font-size: 0.65rem;
            font-family: 'Press Start 2P', monospace;
            
            /* Pixel-like effect */
            clip-path: polygon(
                0 0, 
                calc(100% - var(--pixel-size)) 0, 
                100% var(--pixel-size), 
                100% 100%, 
                var(--pixel-size) 100%, 
                0 calc(100% - var(--pixel-size))
            );
        }

        .context-menu-option {
            padding: 0.5rem 1rem;
            cursor: pointer;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.65rem;
        }

        .context-menu-option:hover {
            background-color: var(--ink-gray-light);
        }

        /* Color Picker */
        .color-picker {
            position: fixed;
            background-color: var(--ink-white);
            color: var(--ink-black);
            padding: 0.5rem;
            border-radius: 0;
            display: none;
            z-index: 1100;
            font-size: 0.65rem;
            font-family: 'Press Start 2P', monospace;
            
            /* Pixel-like effect */
            clip-path: polygon(
                0 0, 
                calc(100% - var(--pixel-size)) 0, 
                100% var(--pixel-size), 
                100% 100%, 
                var(--pixel-size) 100%, 
                0 calc(100% - var(--pixel-size))
            );
        }

        .color-option {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.65rem;
        }

        .color-option:hover {
            background-color: var(--ink-gray-light);
        }

        .color-preview {
            width: 1rem;
            height: 1rem;
            border: 1px solid var(--ink-black);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--ink-white);
            color: var(--ink-black);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 1.5rem;
            position: relative;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.65rem;
            
            /* Pixel-like effect */
            clip-path: polygon(
                0 0, 
                calc(100% - var(--pixel-size)) 0, 
                100% var(--pixel-size), 
                100% 100%, 
                var(--pixel-size) 100%, 
                0 calc(100% - var(--pixel-size))
            );
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--ink-black);
            padding-bottom: 0.5rem;
        }

        .modal-header h2 {
            font-family: 'Press Start 2P', monospace;
            font-size: 1.2rem;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 1.2rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.7rem;
        }

        .form-group input[type="text"],
        .form-group input[type="date"],
        .form-group input[type="time"],
        .form-group input[type="number"],
        .form-group select {
            width: 100%;
            padding: 0.6rem;
            border: 2px solid var(--ink-gray-dark);
            font-family: 'Press Start 2P', monospace;
            font-size: 0.65rem;
        }

        .skill-rating-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.8rem;
        }

        .skill-name-input {
            flex: 1;
            padding: 0.4rem;
            margin-right: 0.5rem;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.65rem;
        }

        .skill-stars-editor {
            display: flex;
            gap: 3px;
        }

        .skill-star-editor {
            cursor: pointer;
            font-size: 1rem;
            color: var(--skill-star-empty);
        }

        .skill-star-editor.filled {
            color: var(--skill-star-filled);
        }

        .remove-skill-btn {
            background: none;
            border: none;
            color: var(--ink-red);
            cursor: pointer;
            font-size: 1rem;
            margin-left: 0.5rem;
        }

        .add-skill-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .add-skill-row input {
            flex: 1;
            padding: 0.4rem;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.65rem;
        }

        .add-skill-row button {
            padding: 0.4rem 1rem;
            background-color: var(--ink-black);
            color: var(--ink-white);
            border: none;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.65rem;
        }

        .submit-btn {
            padding: 0.8rem 1.5rem;
            background-color: var(--ink-black);
            color: var(--ink-white);
            border: none;
            font-size: 0.7rem;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            
            /* Pixel-like effect */
            clip-path: polygon(
                0 0, 
                calc(100% - 4px) 0, 
                100% 4px, 
                100% 100%, 
                4px 100%, 
                0 calc(100% - 4px)
            );
        }

        .submit-btn:hover {
            background-color: var(--ink-gray-dark);
        }

            /* Tutorial Styles */
        /* Tutorial Styles */
        /* Tutorial Styles */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5000;
            pointer-events: none;
            background-color: rgba(0, 0, 0, 0.5); /* Dim the background */
        }

        .tutorial-bubble-container {
            position: absolute;
            display: flex;
            min-width: 550px;
            min-height: 150px;
            z-index: 5001;
            pointer-events: auto;
        }

        .tutorial-bubble {
            position: relative;
            background-color: var(--ink-white);
            color: var(--ink-black);
            padding: 1.5rem;
            width: 100%;
            border-radius: 0;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.65rem;
            line-height: 1.6;
            
            /* Pixel-like effect */
            clip-path: polygon(
                0 0, 
                calc(100% - var(--pixel-size)) 0, 
                100% var(--pixel-size), 
                100% 100%, 
                var(--pixel-size) 100%, 
                0 calc(100% - var(--pixel-size))
            );
        }

        .tutorial-text-container {
            padding-left: 80px; /* Space for character */
        }

        .tutorial-character {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-40%);
            width: 95px;
            height: 130px;
            z-index: 5002;
        }

        .tutorial-character img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .tutorial-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 1.5rem;
        }

        .tutorial-buttons button {
            padding: 0.5rem 1rem;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.6rem;
            background-color: var(--ink-black);
            color: var(--ink-white);
            border: none;
            cursor: pointer;
            
            /* Pixel-like effect */
            clip-path: polygon(
                0 0, 
                calc(100% - 4px) 0, 
                100% 4px, 
                100% 100%, 
                4px 100%, 
                0 calc(100% - 4px)
            );
        }

        .tutorial-buttons button:hover {
            background-color: var(--ink-gray-dark);
        }

        .tutorial-highlight {
            position: absolute;
            border: 3px dashed var(--ink-amber);
            border-radius: 0;
            z-index: 5000;
            pointer-events: none;
            animation: highlight-pulse 1.5s infinite;
        }

        @keyframes highlight-pulse {
            0% { opacity: 0.4; }
            50% { opacity: 0.8; }
            100% { opacity: 0.4; }
        }
    </style>
    <script>
        // Core Dashboard JavaScript
        document.addEventListener('DOMContentLoaded', function() {
            // User data from Flask
            const userData = {{ user|tojson }};
            
            // DOM Elements
            const dashboardArea = document.getElementById('dashboardArea');
            const addWidgetBtn = document.getElementById('addWidgetBtn');
            const widgetMenu = document.getElementById('widgetMenu');
            const contextMenu = document.getElementById('contextMenu');
            const pageContextMenu = document.getElementById('pageContextMenu');
            const colorPicker = document.getElementById('colorPicker');
            const loadingScreen = document.getElementById('loadingScreen');
            const username = document.getElementById('username');
            const userAvatar = document.getElementById('userAvatar');
            const logoutBtn = document.getElementById('logoutBtn');
            const quickMenu = document.getElementById('quickMenu');
            const menuToggleBtn = document.getElementById('menuToggleBtn');
            const collapseMenuBtn = document.getElementById('collapseMenuBtn');
            const menuResizeHandle = document.getElementById('menuResizeHandle');
            const profileEditorModal = document.getElementById('profileEditorModal');
            const closeProfileEditorBtn = document.getElementById('closeProfileEditorBtn');
            const editProfileBtn = document.getElementById('editProfileBtn');
            const profileEditorForm = document.getElementById('profileEditorForm');
            const profileUsername = document.getElementById('profileUsername');
            const profileUniversity = document.getElementById('profileUniversity');
            const profileDepartment = document.getElementById('profileDepartment');
            const profileYear = document.getElementById('profileYear');
            const skillRatingsContainer = document.getElementById('skillRatingsContainer');
            const newSkillInput = document.getElementById('newSkillInput');
            const addSkillBtn = document.getElementById('addSkillBtn');
            const eventEditorModal = document.getElementById('eventEditorModal');
            const closeEventEditorBtn = document.getElementById('closeEventEditorBtn');
            const eventEditorForm = document.getElementById('eventEditorForm');
            const backgroundSettings = document.getElementById('backgroundSettings');
            const widgetColorSettings = document.getElementById('widgetColorSettings');

            // Set username from user data
            username.textContent = userData.username;
            
            // Set avatar if exists
            if (userData.avatar_id) {
                userAvatar.src = `/static/assets/avatars/${userData.avatar_id}.png`;
            }

            // Track active widgets to ensure only one per function exists
            const activeWidgets = {
                profile: false,
                skills: false,
                github: false,
                avatar: false,
                clock: false,
                date: false,
                notes: false,
                spotify: false,
                bounty: false,
                marketplace: false,
                studyspot: false,
                streak: false,
                coins: false,
                qa: false,
                study: false,
                transactions: false,
                tutoring: false,
                messages: false,
                timer: false,
                weather: false,
                calendar: false,
                pomodoro: false,
                pet: false,
                todo: false,
                alarm: false,
                image: false
            };

            // Available avatars
            const availableAvatars = [
                'avatar1', 'avatar2', 'avatar3', 'avatar4', 'avatar5', 'avatar6', 
                'avatar7', 'avatar8', 'avatar9', 'avatar10', 'avatar11', 'avatar12',
                'avatar13', 'avatar14', 'avatar15', 'avatar16', 'avatar17', 'avatar18'
            ];
            
            // Define voxel avatars
            const voxelAvatars = [
                { id: 'voxel1', name: 'Batman', file: 'batman.png' },
                { id: 'voxel2', name: 'Superman', file: 'superman.png' },
                { id: 'voxel3', name: 'Ironman', file: 'ironman.png' },
                { id: 'voxel4', name: 'Captain America', file: 'captain.png' },
                { id: 'voxel5', name: 'Spider-Man', file: 'spiderman.png' },
                { id: 'voxel6', name: 'Wonder Woman', file: 'wonderwoman.png' }
            ];

            // Quick Menu Functionality
            menuToggleBtn.addEventListener('click', () => {
                if (quickMenu.classList.contains('revealed')) {
                    quickMenu.classList.remove('revealed');
                    dashboardArea.classList.remove('menu-revealed');
                    dashboardArea.classList.remove('menu-expanded');
                } else {
                    quickMenu.classList.add('revealed');
                    quickMenu.classList.add('expanded');
                    dashboardArea.classList.add('menu-revealed');
                    dashboardArea.classList.add('menu-expanded');
                }
            });

            collapseMenuBtn.addEventListener('click', () => {
                if (quickMenu.classList.contains('expanded')) {
                    quickMenu.classList.remove('expanded');
                    dashboardArea.classList.remove('menu-expanded');
                } else {
                    quickMenu.classList.add('expanded');
                    dashboardArea.classList.add('menu-expanded');
                }
            });

            // Make quick menu resizable
            let isResizingMenu = false;
            let menuStartX, menuStartWidth;

            menuResizeHandle.addEventListener('mousedown', (e) => {
                isResizingMenu = true;
                menuStartX = e.clientX;
                menuStartWidth = parseInt(window.getComputedStyle(quickMenu).width);
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizingMenu) return;
                
                const newWidth = menuStartWidth + (e.clientX - menuStartX);
                
                // Set minimum and maximum width
                const minWidth = 200;
                const maxWidth = window.innerWidth / 2;
                
                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    quickMenu.style.width = `${newWidth}px`;
                    dashboardArea.style.marginLeft = `${newWidth}px`;
                    document.documentElement.style.setProperty('--menu-width', `${newWidth}px`);
                }
            });

            document.addEventListener('mouseup', () => {
                isResizingMenu = false;
            });

            // Profile Editor Modal
            editProfileBtn.addEventListener('click', () => {
                // Populate form with user data
                profileUsername.value = userData.username || '';
                profileUniversity.value = userData.university || '';
                profileDepartment.value = userData.department || '';
                profileYear.value = userData.year || '';
                
                // Clear existing skills
                skillRatingsContainer.innerHTML = '';
                
                // Add user's skills
                if (userData.skills && userData.skills.length > 0) {
                    userData.skills.forEach(skill => {
                        // Default to middle rating if none is set
                        const rating = userData.skill_ratings ? (userData.skill_ratings[skill] || 3) : 3;
                        const peerCount = userData.skill_peer_ratings ? (userData.skill_peer_ratings[skill] || 0) : 0;
                        
                        addSkillToEditor(skill, rating, peerCount);
                    });
                }
                
                // Show modal
                profileEditorModal.style.display = 'flex';
            });

            closeProfileEditorBtn.addEventListener('click', () => {
                profileEditorModal.style.display = 'none';
            });

            // Close event editor modal
            if (closeEventEditorBtn) {
                closeEventEditorBtn.addEventListener('click', () => {
                    eventEditorModal.style.display = 'none';
                });
            }

            // Close modal when clicking outside
            profileEditorModal.addEventListener('click', (e) => {
                if (e.target === profileEditorModal) {
                    profileEditorModal.style.display = 'none';
                }
            });

            if (eventEditorModal) {
                eventEditorModal.addEventListener('click', (e) => {
                    if (e.target === eventEditorModal) {
                        eventEditorModal.style.display = 'none';
                    }
                });
            }

            // Add skill to editor
            function addSkillToEditor(skill, rating = 3, peerCount = 0) {
                const skillRow = document.createElement('div');
                skillRow.className = 'skill-rating-row';
                
                const skillNameInput = document.createElement('input');
                skillNameInput.type = 'text';
                skillNameInput.className = 'skill-name-input';
                skillNameInput.value = skill;
                
                const starsContainer = document.createElement('div');
                starsContainer.className = 'skill-stars-editor';
                
                for (let i = 1; i <= 5; i++) {
                    const star = document.createElement('span');
                    star.className = `skill-star-editor ${i <= rating ? 'filled' : ''}`;
                    star.innerHTML = 'â˜…';
                    star.dataset.value = i;
                    
                    star.addEventListener('click', function() {
                        const value = parseInt(this.dataset.value);
                        const stars = this.parentNode.querySelectorAll('.skill-star-editor');
                        
                        stars.forEach(s => {
                            if (parseInt(s.dataset.value) <= value) {
                                s.classList.add('filled');
                            } else {
                                s.classList.remove('filled');
                            }
                        });
                    });
                    
                    starsContainer.appendChild(star);
                }
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-skill-btn';
                removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                removeBtn.addEventListener('click', function() {
                    this.closest('.skill-rating-row').remove();
                });
                
                skillRow.appendChild(skillNameInput);
                skillRow.appendChild(starsContainer);
                skillRow.appendChild(removeBtn);
                
                skillRatingsContainer.appendChild(skillRow);
            }

            // Add new skill button
            addSkillBtn.addEventListener('click', () => {
                const skillName = newSkillInput.value.trim();
                if (skillName) {
                    addSkillToEditor(skillName);
                    newSkillInput.value = '';
                }
            });

            // Submit profile form
            profileEditorForm.addEventListener('submit', (e) => {
                e.preventDefault();
                
                // Collect form data
                const updatedUserData = {
                    username: profileUsername.value,
                    university: profileUniversity.value,
                    department: profileDepartment.value,
                    year: profileYear.value,
                    skills: [],
                    skill_ratings: {}
                };
                
                // Get skills and ratings
                const skillRows = skillRatingsContainer.querySelectorAll('.skill-rating-row');
                skillRows.forEach(row => {
                    const skillName = row.querySelector('.skill-name-input').value.trim();
                    if (skillName) {
                        updatedUserData.skills.push(skillName);
                        
                        // Count filled stars
                        const filledStars = row.querySelectorAll('.skill-star-editor.filled').length;
                        updatedUserData.skill_ratings[skillName] = filledStars;
                    }
                });
                
                // Send to server
                fetch('/update-profile', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatedUserData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showNotification('Profile updated successfully!');
                        
                        // Update local user data
                        Object.assign(userData, updatedUserData);
                        
                        // Update username display
                        username.textContent = userData.username;
                        
                        // Update any profile widgets
                        const profileWidgets = document.querySelectorAll('.profile-widget, .skills-widget');
                        profileWidgets.forEach(widget => {
                            const content = widget.querySelector('.widget-content');
                            if (content) {
                                fillWidgetContent(content, widget.dataset.type);
                            }
                        });
                        
                        // Close modal
                        profileEditorModal.style.display = 'none';
                    } else {
                        showNotification('Failed to update profile: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error updating profile:', error);
                    showNotification('Error updating profile');
                });
            });

            // Create Pixel Heart
            const createPixelHeart = () => {
                const heartPattern = [
                    [0, 1, 0, 1, 0],
                    [1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1],
                    [0, 1, 1, 1, 0],
                    [0, 0, 1, 0, 0]
                ];
                
                const pixelHeart = document.getElementById('pixelHeart');
                
                heartPattern.forEach((row, rowIndex) => {
                    row.forEach((col, colIndex) => {
                        if (col) {
                            const div = document.createElement('div');
                            div.className = 'heart-pixel';
                            div.style.gridRow = rowIndex + 1;
                            div.style.gridColumn = colIndex + 1;
                            div.style.setProperty('--index', rowIndex + colIndex);
                            pixelHeart.appendChild(div);
                        }
                    });
                });
            };

            // Show notification
            const showNotification = (message) => {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);

                // Remove notification after animation completes
                setTimeout(() => {
                    notification.remove();
                }, 5000);
            };

            // Save widget to database
            const saveWidgetToDatabase = (widget) => {
                const widgetType = widget.dataset.type;
                const widgetId = widget.dataset.id || null; // Ensure widget ID is captured
                const position = {
                    x: parseInt(widget.style.left),
                    y: parseInt(widget.style.top)
                };
                const size = {
                    width: parseInt(widget.style.width),
                    height: parseInt(widget.style.height)
                };
                const bgColor = widget.style.backgroundColor || '#ffffff';
                const textColor = widget.style.color || '#000000';
                const isPublic = widget.dataset.public === 'true';
                
                // Get any content specific to the widget type
                let content = {};

                // Special content handling based on widget type
                if (widgetType === 'notes') {
                    const textarea = widget.querySelector('textarea');
                    if (textarea) {
                        content.text = textarea.value;
                    }
                } else if (widgetType === 'calendar') {
                    const calendarWidget = widget.querySelector('.calendar-widget');
                    if (calendarWidget) {
                        content.events = calendarData.events || [];
                    }
                } else if (widgetType === 'todo') {
                    const todoItems = widget.querySelectorAll('.todo-item');
                    if (todoItems.length > 0) {
                        content.todos = [];
                        todoItems.forEach(item => {
                            const text = item.querySelector('.todo-text').textContent;
                            const isCompleted = item.querySelector('.todo-checkbox').classList.contains('checked');
                            content.todos.push({ text, completed: isCompleted });
                        });
                    }
                } else if (widgetType === 'pomodoro') {
                    const pomoSettings = widget.querySelector('.pomodoro-widget');
                    if (pomoSettings) {
                        content.workTime = parseInt(widget.querySelector('.work-minutes')?.value) || 25;
                        content.breakTime = parseInt(widget.querySelector('.break-minutes')?.value) || 5;
                        content.longBreakTime = parseInt(widget.querySelector('.long-break-minutes')?.value) || 15;
                    }
                } else if (widgetType === 'pet') {
                    const petWidget = widget.querySelector('.pet-widget');
                    if (petWidget) {
                        content.petType = widget.querySelector('.pet-sprite')?.dataset.petType || 'cat';
                        content.petName = widget.querySelector('.pet-name')?.textContent || 'Pet';
                        content.petHunger = parseInt(widget.querySelector('.hunger-fill')?.style.width) || 100;
                        content.petHappiness = parseInt(widget.querySelector('.happiness-fill')?.style.width) || 100;
                        content.petEnergy = parseInt(widget.querySelector('.energy-fill')?.style.width) || 100;
                    }
                } else if (widgetType === 'alarm') {
                    const alarmItems = widget.querySelectorAll('.alarm-item');
                    if (alarmItems.length > 0) {
                        content.alarms = [];
                        alarmItems.forEach(item => {
                            const time = item.querySelector('.alarm-item-time').textContent;
                            const isActive = item.querySelector('.alarm-item-toggle').classList.contains('active');
                            content.alarms.push({ time, active: isActive });
                        });
                    }
                } else if (widgetType === 'image') {
                    // For image widgets, get the URL from the img element
                    const img = widget.querySelector('.widget-content img');
                    if (img) {
                        content.image_url = img.src;
                        console.log("Adding image URL to widget data:", img.src);
                    }
                }

                // Prepare data to send to server
                const widgetData = {
                    widget_type: widgetType,
                    widget_id: widgetId, // Always send the widget ID to the server
                    position: position,
                    size: size,
                    bg_color: bgColor,
                    text_color: textColor,
                    content: content,
                    is_public: isPublic
                };

                // Save image ID if this is an image widget
                if (widgetType === 'image' && widget.dataset.imageId) {
                    widgetData.image_id = widget.dataset.imageId;
                }

                // Log the widget data for debugging
                console.log("Saving widget data:", widgetData);

                // Send data to server
                fetch('/save-widget', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(widgetData)
                })
                .then(response => response.json())
                .then(data => {
                    if (!data.success) {
                        console.error('Failed to save widget:', data.message);
                    } else {
                        console.log('Widget saved successfully:', data);
                        
                        // If this is a new widget and it received a new ID from the server, update the widget element
                        if (data.widget_id && (!widgetId || widgetId !== data.widget_id)) {
                            widget.dataset.id = data.widget_id;
                            console.log('Updated widget with new ID:', data.widget_id);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error saving widget:', error);
                });
            };

            // Get default widget size based on type
            const getDefaultWidgetSize = (type) => {
                switch(type) {
                    case 'profile':
                        return { width: '300px', height: '200px' };
                    case 'skills':
                        return { width: '250px', height: '180px' };
                    case 'github':
                        return { width: '320px', height: '250px' };
                    case 'avatar':
                        return { width: '300px', height: '300px' };
                    case 'clock':
                        return { width: '200px', height: '120px' };
                    case 'date':
                        return { width: '220px', height: '120px' };
                    case 'notes':
                        return { width: '280px', height: '220px' };
                    case 'spotify':
                        return { width: '280px', height: '200px' };
                    case 'bounty':
                        return { width: '320px', height: '250px' };
                    case 'marketplace':
                        return { width: '300px', height: '250px' };
                    case 'studyspot':
                        return { width: '320px', height: '250px' };
                    case 'streak':
                        return { width: '220px', height: '180px' };
                    case 'coins':
                        return { width: '250px', height: '180px' };
                    case 'qa':
                        return { width: '300px', height: '250px' };
                    case 'study':
                        return { width: '300px', height: '220px' };
                    case 'transactions':
                        return { width: '320px', height: '250px' };
                    case 'tutoring':
                        return { width: '300px', height: '250px' };
                    case 'messages':
                        return { width: '280px', height: '220px' };
                    case 'timer':
                        return { width: '220px', height: '180px' };
                    case 'weather':
                        return { width: '250px', height: '180px' };
                    // New widget sizes
                    case 'calendar':
                        return { width: '320px', height: '320px' };
                    case 'pomodoro':
                        return { width: '250px', height: '220px' };
                    case 'pet':
                        return { width: '250px', height: '220px' };
                    case 'todo':
                        return { width: '280px', height: '300px' };
                    case 'alarm':
                        return { width: '250px', height: '220px' };
                    case 'image':
                        return { width: '300px', height: '240px' };
                    default:
                        return { width: '250px', height: '180px' };
                }
            };

            // Get widget title based on type
            const getWidgetTitle = (type) => {
                const titles = {
                    profile: 'Profile',
                    skills: 'Skills',
                    github: 'GitHub',
                    avatar: 'Avatar',
                    clock: 'Clock',
                    date: 'Date',
                    notes: 'Notes',
                    spotify: 'Spotify',
                    bounty: 'Knowledge Bounties',
                    marketplace: 'Marketplace',
                    studyspot: 'Study Spots',
                    streak: 'Login Streak',
                    coins: 'Coin Balance',
                    qa: 'Q&A Activity',
                    study: 'Study Tracker',
                    transactions: 'Transactions',
                    tutoring: 'Tutoring',
                    messages: 'Messages',
                    timer: 'Timer',
                    weather: 'Weather',
                    calendar: 'Calendar',
                    pomodoro: 'Pomodoro Timer',
                    pet: 'Virtual Pet',
                    todo: 'To-Do List',
                    alarm: 'Alarm',
                    image: 'Image'
                };
                return titles[type] || type.charAt(0).toUpperCase() + type.slice(1);
            };

            function updateWidgetResponsiveDisplay(widget) {
                // Get widget dimensions
                const width = parseInt(widget.style.width) || widget.offsetWidth;
                const height = parseInt(widget.style.height) || widget.offsetHeight;
                
                // Different handlers for different widget types
                const widgetType = widget.dataset.type;
                
                // Add .compact-view class to widgets below certain dimensions
                if (width < 200 || height < 150) {
                    widget.classList.add('compact-view');
                } else {
                    widget.classList.remove('compact-view');
                }
                
                // Widget-specific responsive behavior
                switch(widgetType) {
                    case 'todo':
                        handleTodoResponsive(widget, width, height);
                        break;
                    case 'pomodoro':
                        handlePomodoroResponsive(widget, width, height);
                        break;
                    case 'calendar':
                        handleCalendarResponsive(widget, width, height);
                        break;
                    case 'timer':
                        handleTimerResponsive(widget, width, height);
                        break;
                    case 'alarm':
                        handleAlarmResponsive(widget, width, height);
                        break;
                    // Add cases for other widget types as needed
                }
            }

            function handleTimerResponsive(widget, width, height) {
                const display = widget.querySelector('.timer-display');
                const controls = widget.querySelector('.timer-controls');
                const setup = widget.querySelector('.timer-setup');
                const presets = widget.querySelector('.timer-presets');
                
                // Always ensure timer display is visible
                if (display) {
                    display.style.display = 'block';
                    
                    // Adjust font size based on available space
                    if (width < 150 || height < 120) {
                        display.style.fontSize = '1rem';
                        display.style.margin = '5px 0';
                    } else if (width < 180 || height < 150) {
                        display.style.fontSize = '1.2rem';
                        display.style.margin = '10px 0';
                    } else {
                        display.style.fontSize = '1.8rem';
                        display.style.margin = '15px 0';
                    }
                }
                
                // Hide elements based on available space
                if (width < 130 || height < 100) {
                    // Extremely small - show only timer display
                    if (controls) controls.style.display = 'none';
                    if (setup) setup.style.display = 'none';
                    if (presets) presets.style.display = 'none';
                } else if (width < 160 || height < 130) {
                    // Very small - show timer and minimal controls
                    if (controls) {
                        controls.style.display = 'flex';
                        controls.style.gap = '5px';
                        
                        // Adjust button size
                        const buttons = controls.querySelectorAll('button');
                        buttons.forEach(btn => {
                            btn.style.padding = '2px 5px';
                            btn.style.fontSize = '0.5rem';
                        });
                    }
                    
                    // Hide input fields and presets
                    if (setup) setup.style.display = 'none';
                    if (presets) presets.style.display = 'none';
                } else if (width < 180 || height < 150) {
                    // Small - show timer and controls, but hide presets
                    if (controls) {
                        controls.style.display = 'flex';
                        controls.style.gap = '10px';
                        
                        // Reset button size
                        const buttons = controls.querySelectorAll('button');
                        buttons.forEach(btn => {
                            btn.style.padding = '0.3rem 0.5rem';
                            btn.style.fontSize = '0.6rem';
                        });
                    }
                    
                    // Show minimal setup with smaller inputs
                    if (setup) {
                        setup.style.display = 'flex';
                        setup.style.flexWrap = 'wrap';
                        setup.style.justifyContent = 'center';
                        
                        // Make inputs smaller
                        const inputs = setup.querySelectorAll('input');
                        inputs.forEach(input => {
                            input.style.width = '25px';
                            input.style.padding = '2px';
                            input.style.fontSize = '0.5rem';
                        });
                        
                        // Make labels smaller
                        const labels = setup.querySelectorAll('.timer-label');
                        labels.forEach(label => {
                            label.style.fontSize = '0.5rem';
                        });
                    }
                    
                    // Hide presets
                    if (presets) presets.style.display = 'none';
                } else {
                    // Normal size - show everything
                    if (controls) {
                        controls.style.display = 'flex';
                        controls.style.gap = '15px';
                        
                        // Reset button size
                        const buttons = controls.querySelectorAll('button');
                        buttons.forEach(btn => {
                            btn.style.padding = '0.5rem 0.8rem';
                            btn.style.fontSize = '0.6rem';
                        });
                    }
                    
                    // Show full setup
                    if (setup) {
                        setup.style.display = 'flex';
                        setup.style.flexWrap = 'nowrap';
                        
                        // Reset input size
                        const inputs = setup.querySelectorAll('input');
                        inputs.forEach(input => {
                            input.style.width = '40px';
                            input.style.padding = '0.3rem';
                            input.style.fontSize = '0.6rem';
                        });
                        
                        // Reset label size
                        const labels = setup.querySelectorAll('.timer-label');
                        labels.forEach(label => {
                            label.style.fontSize = '0.6rem';
                        });
                    }
                    
                    // Show presets
                    if (presets) presets.style.display = 'flex';
                }
            }

            // Helper functions for specific widget types
            function handleTodoResponsive(widget, width, height) {
                const todoStats = widget.querySelector('.todo-stats');
                const todoInput = widget.querySelector('.todo-input');
                const todoList = widget.querySelector('.todo-list');
                
                if (width < 180 || height < 180) {
                    // Super compact view - just show task list
                    if (todoStats) todoStats.style.display = 'none';
                    if (todoInput) {
                        todoInput.style.fontSize = '0.55rem';
                        todoInput.style.padding = '0.2rem 0.4rem';
                    }
                    
                    // Ensure todoList takes maximum available space
                    if (todoList) {
                        todoList.style.maxHeight = 'calc(100% - 35px)';
                    }
                } else {
                    // Normal view
                    if (todoStats) todoStats.style.display = 'flex';
                    if (todoInput) {
                        todoInput.style.fontSize = '0.6rem';
                        todoInput.style.padding = '0.3rem 0.5rem';
                    }
                    if (todoList) {
                        todoList.style.maxHeight = '200px';
                    }
                }
            }

            function handlePomodoroResponsive(widget, width, height) {
                const timer = widget.querySelector('.pomodoro-timer');
                const phase = widget.querySelector('.pomodoro-phase');
                const progress = widget.querySelector('.pomodoro-progress');
                const stats = widget.querySelector('.pomodoro-stats');
                const buttons = widget.querySelectorAll('.pomodoro-btn');
                
                if (width < 180 || height < 180) {
                    // Super compact view - just show timer and butto

                    if (timer) timer.style.fontSize = '1.2rem';
                    if (phase) phase.style.display = 'none';
                    if (progress) progress.style.display = 'none';
                    if (stats) stats.style.display = 'none';
                    
                    buttons.forEach(btn => {
                        btn.style.padding = '0.2rem 0.4rem';
                        btn.style.fontSize = '0.5rem';
                    });
                } else {
                    // Normal view
                    if (timer) timer.style.fontSize = '2rem';
                    if (phase) phase.style.display = 'block';
                    if (progress) progress.style.display = 'block';
                    if (stats) stats.style.display = 'flex';
                    
                    buttons.forEach(btn => {
                        btn.style.padding = '0.5rem 0.8rem';
                        btn.style.fontSize = '0.6rem';
                    });
                }
            }

            function handleCalendarResponsive(widget, width, height) {
                const calendarGrid = widget.querySelector('.calendar-grid');
                const timetable = widget.querySelector('.calendar-timetable');
                
                if (width < 250 || height < 200) {
                    // Simplify calendar in compact view
                    if (calendarGrid) {
                        // Make day headers smaller
                        const dayHeaders = calendarGrid.querySelectorAll('.calendar-day-header');
                        dayHeaders.forEach(header => {
                            header.style.fontSize = '0.5rem';
                            header.textContent = header.textContent.substr(0, 1); // Just show first letter
                        });
                        
                        // Make days smaller
                        const days = calendarGrid.querySelectorAll('.calendar-day');
                        days.forEach(day => {
                            day.style.fontSize = '0.55rem';
                        });
                    }
                    
                    // Hide timetable in very compact view
                    if (height < 180 && timetable) {
                        timetable.style.display = 'none';
                    }
                } else {
                    // Reset to normal view
                    if (calendarGrid) {
                        const dayHeaders = calendarGrid.querySelectorAll('.calendar-day-header');
                        dayHeaders.forEach(header => {
                            header.style.fontSize = '0.6rem';
                            // Restore day names based on index
                            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                            const index = Array.from(dayHeaders).indexOf(header);
                            if (index >= 0 && index < 7) {
                                header.textContent = dayNames[index];
                            }
                        });
                        
                        const days = calendarGrid.querySelectorAll('.calendar-day');
                        days.forEach(day => {
                            day.style.fontSize = '0.65rem';
                        });
                    }
                    
                    // Show timetable again
                    if (timetable) {
                        timetable.style.display = 'block';
                    }
                }
            }

            function handleTimerResponsive(widget, width, height) {
                const display = widget.querySelector('.timer-display');
                const controls = widget.querySelector('.timer-controls');
                const setup = widget.querySelector('.timer-setup');
                const presets = widget.querySelector('.timer-presets');
                
                if (width < 180 || height < 150) {
                    if (display) display.style.fontSize = '1.2rem';
                    if (presets) presets.style.display = 'none';
                    
                    if (height < 120 && setup) {
                        setup.style.display = 'none';
                    }
                } else {
                    if (display) display.style.fontSize = '1.8rem';
                    if (presets) presets.style.display = 'flex';
                    if (setup) setup.style.display = 'flex';
                }
            }

            function handleAlarmResponsive(widget, width, height) {
                const time = widget.querySelector('.alarm-time');
                const status = widget.querySelector('.alarm-status');
                const list = widget.querySelector('.alarm-list');
                
                if (width < 180 || height < 150) {
                    if (time) time.style.fontSize = '1.5rem';
                    if (list) list.style.maxHeight = '60px';
                    
                    if (height < 120 && status) {
                        status.style.display = 'none';
                    }
                } else {
                    if (time) time.style.fontSize = '2rem';
                    if (status) status.style.display = 'block';
                    if (list) list.style.maxHeight = '100px';
                }
            }
            
            // Global data for widget functionality
            const calendarData = {
                currentDate: new Date(),
                events: [],
                selectedDate: null
            };
            
            const pomodoroData = {
                workTime: 25,  // minutes
                breakTime: 5,  // minutes
                longBreakTime: 15,  // minutes
                currentPhase: 'work', // 'work', 'break', 'longBreak'
                isRunning: false,
                timeLeft: 25 * 60, // seconds
                interval: null,
                completedPomodoros: 0
            };
            
            const petData = {
                type: 'cat',
                name: 'Pixel',
                hunger: 100,
                happiness: 100,
                energy: 100,
                lastInteraction: new Date(),
                animations: {
                    idle: ['cat_idle_1.png', 'cat_idle_2.png'],
                    eating: ['cat_eating_1.png', 'cat_eating_2.png'],
                    sleeping: ['cat_sleeping_1.png', 'cat_sleeping_2.png'],
                    playing: ['cat_playing_1.png', 'cat_playing_2.png']
                },
                currentState: 'idle',
                decreaseInterval: null
            };
            
            const alarmData = {
                alarms: [],
                activeAlarm: null,
                checkInterval: null
            };
            
            // Widget Creation Functions
            const createWidget = (type, x, y, options = {}) => {
                // Check if widget already exists (except for notes and image widgets)
                if (activeWidgets[type] && type !== 'notes' && type !== 'image') {
                    showNotification(`A ${type} widget already exists!`);
                    return;
                }
                
                // Generate a temporary ID for the widget
                // This will be replaced with the actual ID from the server after saving
                const tempWidgetId = options.widgetId || `${type}-${Date.now()}`;
                
                // Mark as active
                activeWidgets[type] = true;
                
                // Create widget element
                const widget = document.createElement('div');
                widget.className = `widget ${type}-widget`;
                widget.dataset.type = type;
                widget.dataset.id = tempWidgetId;
                widget.style.left = `${x}px`;
                widget.style.top = `${y}px`;
                
                // Set initial public/private status
                widget.dataset.public = options.isPublic ? 'true' : 'false';
                
                // Set width and height based on widget type or options
                widget.style.width = options.width || getDefaultWidgetSize(type).width;
                widget.style.height = options.height || getDefaultWidgetSize(type).height;
                
                // Set colors if provided
                if (options.bgColor) widget.style.backgroundColor = options.bgColor;
                if (options.textColor) widget.style.color = options.textColor;
                
                // Special case for image widget - different structure
                if (type === 'image') {
                    // Create header (initially hidden until hover)
                    const header = document.createElement('div');
                    header.className = 'widget-header';
                    
                    const title = document.createElement('div');
                    title.className = 'widget-title';
                    title.textContent = getWidgetTitle(type);
                    
                    header.appendChild(title);
                    widget.appendChild(header);
                    
                    // Create content
                    const content = document.createElement('div');
                    content.className = 'widget-content';
                    
                    // If image is already provided (from database)
                    if (options.content && options.content.image_url) {
                        console.log("Creating image widget with URL:", options.content.image_url);
                        const img = document.createElement('img');
                        img.src = options.content.image_url;
                        img.alt = 'Uploaded Image';
                        
                        // Add error handling to diagnose image loading issues
                        img.onerror = function() {
                            console.error("Failed to load image from URL:", options.content.image_url);
                        };
                        
                        img.onload = function() {
                            console.log("Image loaded successfully:", options.content.image_url);
                        };
                        
                        content.appendChild(img);
                        
                        // Store the image ID if available
                        if (options.content.image_id) {
                            widget.dataset.imageId = options.content.image_id;
                        }
                    } else {
                        // Show upload placeholder
                        const uploadPlaceholder = document.createElement('div');
                        uploadPlaceholder.className = 'image-upload-form';
                        uploadPlaceholder.innerHTML = `
                            <i class="fas fa-cloud-upload-alt"></i>
                            <label class="image-upload-label">Click to upload image</label>
                            <input type="file" accept="image/*" class="image-upload-input">
                        `;
                        content.appendChild(uploadPlaceholder);
                        
                        // Handle image upload
                        const fileInput = uploadPlaceholder.querySelector('input[type="file"]');
                        uploadPlaceholder.addEventListener('click', () => {
                            fileInput.click();
                        });
                        
                        fileInput.addEventListener('change', () => {
                            if (fileInput.files && fileInput.files[0]) {
                                const formData = new FormData();
                                formData.append('image', fileInput.files[0]);
                                
                                // Show loading state
                                uploadPlaceholder.innerHTML = '<i class="fas fa-spinner fa-spin"></i><div>Uploading...</div>';
                                
                                // Upload to server
                                fetch('/upload-image', {
                                    method: 'POST',
                                    body: formData
                                })
                                .then(response => response.json())
                                .then(data => {
                                    if (data.success) {
                                        console.log("Image upload successful:", data);
                                        
                                        // Replace placeholder with image
                                        content.innerHTML = '';
                                        const img = document.createElement('img');
                                        img.src = data.image_url;
                                        img.alt = 'Uploaded Image';
                                        
                                        // Add error handling for new image
                                        img.onerror = function() {
                                            console.error("Failed to load newly uploaded image:", data.image_url);
                                        };
                                        
                                        img.onload = function() {
                                            console.log("Newly uploaded image loaded successfully:", data.image_url);
                                        };
                                        
                                        content.appendChild(img);
                                        
                                        // Store the image ID
                                        widget.dataset.imageId = data.image_id;
                                        
                                        // Save widget state
                                        saveWidgetToDatabase(widget);
                                    } else {
                                        // Show error
                                        uploadPlaceholder.innerHTML = `
                                            <i class="fas fa-exclamation-circle"></i>
                                            <div>Upload failed: ${data.message}</div>
                                            <div>Click to try again</div>
                                        `;
                                    }
                                })
                                .catch(error => {
                                    console.error('Error uploading image:', error);
                                    uploadPlaceholder.innerHTML = `
                                        <i class="fas fa-exclamation-circle"></i>
                                        <div>Upload failed</div>
                                        <div>Click to try again</div>
                                    `;
                                });
                            }
                        });
                    }
                    
                    widget.appendChild(content);
                } else {
                    // Standard widget structure
                    // Create header
                    const header = document.createElement('div');
                    header.className = 'widget-header';
                    
                    const title = document.createElement('div');
                    title.className = 'widget-title';
                    title.textContent = getWidgetTitle(type);
                    
                    header.appendChild(title);
                    widget.appendChild(header);
                    
                    // Create content
                    const content = document.createElement('div');
                    content.className = 'widget-content';
                    
                    // Fill content based on widget type
                    fillWidgetContent(content, type, options.content);
                    
                    widget.appendChild(content);
                }
                
                // Add resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                widget.appendChild(resizeHandle);
                
                dashboardArea.appendChild(widget);
                
                // Make the widget draggable
                makeDraggable(widget);

                // Make the widget resizable
                makeResizable(widget, resizeHandle);

                // Set up responsive display
                updateWidgetResponsiveDisplay(widget);
                
                // Add context menu to widget
                widget.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    
                    // Show context menu at cursor position
                    contextMenu.style.display = 'block';
                    contextMenu.style.left = `${e.clientX}px`;
                    contextMenu.style.top = `${e.clientY}px`;
                    
                    // Store the widget id in the context menu
                    contextMenu.dataset.widgetId = widget.dataset.id;
                    
                    // Add Change Avatar option specifically for avatar widgets
                    if (widget.dataset.type === 'avatar') {
                        const existingOption = Array.from(contextMenu.querySelectorAll('.context-menu-option'))
                            .find(option => option.dataset.action === 'change-avatar');
                            
                        if (!existingOption) {
                            const newOption = document.createElement('div');
                            newOption.className = 'context-menu-option';
                            newOption.dataset.action = 'change-avatar';
                            newOption.innerHTML = '<i class="fas fa-user-circle"></i> Change Avatar';
                            contextMenu.insertBefore(newOption, contextMenu.querySelector('[data-action="remove"]'));
                        }
                    } else {
                        // Remove Change Avatar option if not an avatar widget
                        const existingOption = Array.from(contextMenu.querySelectorAll('.context-menu-option'))
                            .find(option => option.dataset.action === 'change-avatar');
                        if (existingOption) {
                            contextMenu.removeChild(existingOption);
                        }
                    }

                    // Update visibility toggle text based on current status
                    const visibilityToggle = contextMenu.querySelector('[data-action="visibility-toggle"]');
                    if (visibilityToggle) {
                        const isPublic = widget.dataset.public === 'true';
                        visibilityToggle.innerHTML = `<i class="fas fa-eye${isPublic ? '' : '-slash'}"></i> Make ${isPublic ? 'Private' : 'Public'}`;
                    }
                });
                
                // Save widget to database and update the widget with the returned ID
                saveWidgetToDatabase(widget);
                
                return widget;
            };
            
            // Fill widget content based on type
            const fillWidgetContent = (contentElement, type, customContent = null) => {
                switch(type) {
                    case 'profile':
                        contentElement.innerHTML = `
                            <div class="profile-info">
                                <div><strong>Username:</strong> ${userData.username}</div>
                                <div><strong>University:</strong> ${userData.university || 'Not set'}</div>
                                <div><strong>Department:</strong> ${userData.department || 'Not set'}</div>
                                <div><strong>Year:</strong> ${userData.year || 'Not set'}</div>
                            </div>
                        `;
                        break;
                    case 'skills':
                        // If we have skill ratings data, show the rated skills
                        if (userData.skills && userData.skills.length > 0) {
                            let skillsHtml = '<div class="skills-container">';
                            
                            userData.skills.forEach(skill => {
                                // Get rating (default to 3 if not set)
                                const rating = userData.skill_ratings ? (userData.skill_ratings[skill] || 3) : 3;
                                // Get peer count (default to 0 if not set)
                                const peerCount = userData.skill_peer_ratings ? (userData.skill_peer_ratings[skill] || 0) : 0;
                                
                                // Generate stars HTML
                                let starsHtml = '';
                                for (let i = 1; i <= 5; i++) {
                                    starsHtml += `<span class="skill-star ${i <= rating ? 'filled' : ''}">â˜…</span>`;
                                }
                                
                                // Add peer validation if available
                                const peerText = peerCount > 0 ? ` by ${peerCount} peer${peerCount !== 1 ? 's' : ''}` : '';
                                
                                skillsHtml += `
                                    <div class="skill-rating">
                                        <div class="skill-name">${skill}</div>
                                        <div class="skill-stars">
                                            ${starsHtml}
                                        </div>
                                        <div class="skill-peer-count">${peerText}</div>
                                    </div>
                                `;
                            });
                            
                            skillsHtml += '</div>';
                            contentElement.innerHTML = skillsHtml;
                        } else {
                            // Fallback to simple skill tags if no ratings
                            contentElement.innerHTML = userData.skills ? 
                                userData.skills.map(skill => 
                                    `<div class="skill-tag">${skill}</div>`
                                ).join('') : 
                                '<div>No skills added yet</div>';
                        }
                        break;
                    case 'github':
                        if (userData.github_username) {
                            // First show loading state
                            contentElement.innerHTML = `<div>Loading GitHub projects...</div>`;
                            
                            // Fetch GitHub repos
                            fetch('/get-github-repos')
                                .then(response => response.json())
                                .then(data => {
                                    if (data.success && data.repos && data.repos.length > 0) {
                                        contentElement.innerHTML = `
                                            <div><strong>${userData.github_username}</strong></div>
                                            ${data.repos.slice(0, 3).map(repo => `
                                                <div class="github-project">
                                                    <div class="github-project-title">${repo.name}</div>
                                                    <div class="github-project-description">${repo.description || 'No description'}</div>
                                                    <div class="github-project-meta">
                                                        <span>${repo.language || 'N/A'}</span>
                                                        <span>â­ ${repo.stars}</span>
                                                        <span>ðŸ´ ${repo.forks}</span>
                                                    </div>
                                                </div>
                                            `).join('')}
                                        `;
                                    } else {
                                        contentElement.innerHTML = `
                                            <div><strong>${userData.github_username}</strong></div>
                                            <div>No repositories found</div>
                                        `;
                                    }
                                })
                                .catch(error => {
                                    console.error('Error fetching GitHub repos:', error);
                                    contentElement.innerHTML = `
                                        <div><strong>${userData.github_username}</strong></div>
                                        <div>Error fetching repositories</div>
                                    `;
                                });
                        } else {
                            contentElement.innerHTML = `
                                <div>No GitHub account connected</div>
                                <div style="margin-top: 10px;">
                                    <a href="/github-login" style="color: inherit; text-decoration: underline;">Connect GitHub</a>
                                </div>
                            `;
                        }
                        break;
                    case 'streak':
                        // Fetch streak data from the server
                        fetch('/get-login-streak')
                            .then(response => response.json())
                            .then(data => {
                                if (data.success) {
                                    // Generate streak days visualization
                                    let streakDaysHtml = '<div class="streak-days">';
                                    for (let i = 6; i >= 0; i--) {
                                        const isActive = data.lastWeek && data.lastWeek[i];
                                        streakDaysHtml += `<div class="streak-day ${isActive ? 'active' : ''}"></div>`;
                                    }
                                    streakDaysHtml += '</div>';
                                    
                                    contentElement.innerHTML = `
                                        <div class="streak-count">${data.currentStreak}</div>
                                        <div class="streak-label">day${data.currentStreak !== 1 ? 's' : ''} streak</div>
                                        <div>Best: ${data.longestStreak} days</div>
                                        ${streakDaysHtml}
                                        <div style="font-size: 0.6rem; margin-top: 8px;">Last 7 days</div>
                                    `;
                                } else {
                                    contentElement.innerHTML = `
                                        <div class="streak-count">0</div>
                                        <div class="streak-label">days streak</div>
                                        <div>Start your streak by logging in daily!</div>
                                    `;
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching streak data:', error);
                                contentElement.innerHTML = `
                                    <div>Error loading streak data</div>
                                `;
                            });
                        break;
                    case 'avatar':
                        // Get current voxel avatar or default
                        const currentVoxelId = userData.voxel_avatar_id || 'voxel1';
                        const currentVoxel = voxelAvatars.find(avatar => avatar.id === currentVoxelId) || voxelAvatars[0];
                        
                        contentElement.innerHTML = `
                            <div class="voxel-avatar-container">
                                <img src="/static/assets/voxels/${currentVoxel.file}" 
                                     alt="${currentVoxel.name}" 
                                     class="current-voxel-avatar" 
                                     data-voxel="${currentVoxel.id}">
                                <div class="voxel-avatar-name">${currentVoxel.name}</div>
                            </div>
                        `;
                        break;
                    case 'clock':
                        const clockDiv = document.createElement('div');
                        clockDiv.id = `clock-${Date.now()}`;
                        contentElement.appendChild(clockDiv);
                        
                        // Update time function
                        const updateClock = (id) => {
                            const now = new Date();
                            const hours = now.getHours().toString().padStart(2, '0');
                            const minutes = now.getMinutes().toString().padStart(2, '0');
                            const seconds = now.getSeconds().toString().padStart(2, '0');
                            
                            const clockElement = document.getElementById(id);
                            if (clockElement) {
                                clockElement.textContent = `${hours}:${minutes}:${seconds}`;
                            }
                        };
                        
                        // Initial update
                        updateClock(clockDiv.id);
                        
                        // Set interval for updates
                        const clockInterval = setInterval(() => updateClock(clockDiv.id), 1000);
                        
                        // Store interval ID to clear when widget is removed
                        clockDiv.dataset.intervalId = clockInterval;
                        break;
                    case 'date':
                        const dateDiv = document.createElement('div');
                        
                        const now = new Date();
                        const options = { 
                            weekday: 'long', 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric' 
                        };
                        dateDiv.textContent = now.toLocaleDateString('en-US', options);
                        
                        contentElement.appendChild(dateDiv);
                        break;
                    case 'notes':
                        const textarea = document.createElement('textarea');
                        textarea.placeholder = 'Write your notes here...';
                        
                        // If we have custom content, set it
                        if (customContent && customContent.text) {
                            textarea.value = customContent.text;
                        }
                        
                        // Auto-save notes on change
                        textarea.addEventListener('input', () => {
                            // Get widget element to save
                            const widget = textarea.closest('.widget');
                            if (widget) {
                                saveWidgetToDatabase(widget);
                            }
                        });
                        
                        contentElement.appendChild(textarea);
                        break;
                    case 'spotify':
                        // Set up a container with an ID for easy updating
                        const spotifyId = `spotify-${Date.now()}`;
                        contentElement.innerHTML = `<div id="${spotifyId}"><div class="spotify-track-info">Loading Spotify data...</div></div>`;
                        
                        // Function to update Spotify content
                        const updateSpotifyWidget = (container) => {
                            fetch('/spotify-current-track')
                                .then(response => response.json())
                                .then(data => {
                                    if (data.success) {
                                        if (data.playing === false) {
                                            container.innerHTML = `
                                                <div class="spotify-track-info">
                                                    <div>No track currently playing</div>
                                                </div>
                                                <div class="spotify-controls">
                                                    <button class="spotify-control-btn" data-action="previous"><i class="fas fa-step-backward"></i></button>
                                                    <button class="spotify-control-btn" data-action="play"><i class="fas fa-play"></i></button>
                                                    <button class="spotify-control-btn" data-action="next"><i class="fas fa-step-forward"></i></button>
                                                </div>
                                            `;
                                        } else {
                                            const track = data.track;
                                            
                                            // Store track data for progress updates
                                            container.dataset.trackId = track.id;
                                            container.dataset.progressMs = track.progress_ms;
                                            container.dataset.durationMs = track.duration_ms;
                                            container.dataset.lastUpdate = Date.now();
                                            
                                            const progressPercent = (track.progress_ms / track.duration_ms) * 100;
                                            
                                            container.innerHTML = `
                                                <div class="spotify-track-info">
                                                    ${track.image ? `<img src="${track.image}" class="spotify-track-image" alt="Album Cover">` : ''}
                                                    <div class="spotify-track-name">${track.track_name}</div>
                                                    <div class="spotify-track-artist">${track.artist}</div>
                                                </div>
                                                <div class="spotify-progress-bar">
                                                    <div class="spotify-progress" style="width: ${progressPercent}%"></div>
                                                </div>
                                                <div class="spotify-controls">
                                                    <button class="spotify-control-btn" data-action="previous"><i class="fas fa-step-backward"></i></button>
                                                    <button class="spotify-control-btn" data-action="${track.playing ? 'pause' : 'play'}">
                                                        <i class="fas fa-${track.playing ? 'pause' : 'play'}"></i>
                                                    </button>
                                                    <button class="spotify-control-btn" data-action="next"><i class="fas fa-step-forward"></i></button>
                                                </div>
                                            `;
                                        }
                                        
                                        // Add control button listeners
                                        const controlButtons = container.querySelectorAll('.spotify-control-btn');
                                        controlButtons.forEach(button => {
                                            button.addEventListener('click', () => {
                                                const action = button.dataset.action;
                                                
                                                fetch('/spotify-control', {
                                                    method: 'POST',
                                                    headers: {
                                                        'Content-Type': 'application/json'
                                                    },
                                                    body: JSON.stringify({ action })
                                                })
                                                .then(response => response.json())
                                                .then(data => {
                                                    if (data.success) {
                                                        // Wait a bit then update the widget
                                                        setTimeout(() => updateSpotifyWidget(container), 1000);
                                                    } else {
                                                        showNotification('Failed to control playback: ' + data.message);
                                                    }
                                                })
                                                .catch(error => {
                                                    console.error('Error controlling Spotify:', error);
                                                    showNotification('Error controlling Spotify');
                                                });
                                            });
                                        });
                                    } else {
                                        // No Spotify account connected
                                        container.innerHTML = `
                                            <div style="text-align: center; padding: 20px;">
                                                <i class="fab fa-spotify" style="font-size: 2rem; margin-bottom: 10px;"></i>
                                                <div>Connect your Spotify account to see and control your music</div>
                                                <a href="/spotify-login" class="spotify-connect-btn">Connect Spotify</a>
                                            </div>
                                        `;
                                    }
                                })
                                .catch(error => {
                                    console.error('Error fetching Spotify data:', error);
                                    container.innerHTML = `
                                        <div>Error connecting to Spotify</div>
                                        <a href="/spotify-login" class="spotify-connect-btn">Reconnect Spotify</a>
                                    `;
                                });
                        };
                        
                        // Function to update progress bar in real time
                        const updateSpotifyProgress = (container) => {
                            if (!container) return;
                            
                            // Check if we have track data
                            const trackId = container.dataset.trackId;
                            if (!trackId) return;
                            
                            const progressMs = parseInt(container.dataset.progressMs || 0);
                            const durationMs = parseInt(container.dataset.durationMs || 1);
                            const lastUpdate = parseInt(container.dataset.lastUpdate || Date.now());
                            
                            // Calculate elapsed time since last update
                            const now = Date.now();
                            const elapsed = now - lastUpdate;
                            
                            // Calculate new progress
                            const newProgress = progressMs + elapsed;
                            
                            // Update progress bar if we didn't reach the end
                            if (newProgress < durationMs) {
                                const progressPercent = (newProgress / durationMs) * 100;
                                const progressBar = container.querySelector('.spotify-progress');
                                if (progressBar) {
                                    progressBar.style.width = `${progressPercent}%`;
                                }
                                
                                // Update stored progress
                                container.dataset.progressMs = newProgress;
                                container.dataset.lastUpdate = now;
                            } else {
                                // Song might have ended, refresh data
                                updateSpotifyWidget(container);
                            }
                        };
                        
                        // Initial update
                        const spotifyContainer = document.getElementById(spotifyId);
                        updateSpotifyWidget(spotifyContainer);
                        
                        // Set up intervals for updates
                        const progressInterval = setInterval(() => {
                            const container = document.getElementById(spotifyId);
                            if (container) {
                                updateSpotifyProgress(container);
                            } else {
                                clearInterval(progressInterval);
                            }
                        }, 1000); // Update progress every second
                        
                        const refreshInterval = setInterval(() => {
                            const container = document.getElementById(spotifyId);
                            if (container) {
                                updateSpotifyWidget(container);
                            } else {
                                clearInterval(refreshInterval);
                            }
                        }, 30000); // Refresh data every 30 seconds
                        
                        // Store interval IDs to clear when widget is removed
                        contentElement.dataset.progressIntervalId = progressInterval;
                        contentElement.dataset.refreshIntervalId = refreshInterval;
                        break;
                        
                    // New widgets start here
                    case 'calendar':
                        // If we have custom content, load the events
                        if (customContent && customContent.events) {
                            calendarData.events = customContent.events;
                        }
                        
                        // Create calendar container
                        contentElement.innerHTML = `
                            <div class="calendar-header">
                                <div class="calendar-nav">
                                    <button class="calendar-btn" id="prev-month"><i class="fas fa-chevron-left"></i></button>
                                </div>
                                <div class="calendar-title" id="calendar-month-year"></div>
                                <div class="calendar-nav">
                                    <button class="calendar-btn" id="next-month"><i class="fas fa-chevron-right"></i></button>
                                </div>
                            </div>
                            <div class="calendar-grid" id="calendar-grid"></div>
                            <div class="calendar-timetable" id="calendar-timetable"></div>
                        `;
                        
                        // Initialize the calendar
                        const calendarId = Date.now();
                        contentElement.querySelector('.calendar-grid').id = `calendar-grid-${calendarId}`;
                        contentElement.querySelector('.calendar-title').id = `calendar-month-year-${calendarId}`;
                        contentElement.querySelector('.calendar-timetable').id = `calendar-timetable-${calendarId}`;
                        
                        // Function to render the calendar
                        const renderCalendar = (calendarElement, date) => {
                            const monthYear = calendarElement.querySelector(`#calendar-month-year-${calendarId}`);
                            const grid = calendarElement.querySelector(`#calendar-grid-${calendarId}`);
                            
                            // Set month and year
                            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                            monthYear.textContent = `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
                            
                            // Clear grid
                            grid.innerHTML = '';
                            
                            // Add day headers
                            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                            dayNames.forEach(day => {
                                const dayHeader = document.createElement('div');
                                dayHeader.className = 'calendar-day-header';
                                dayHeader.textContent = day;
                                grid.appendChild(dayHeader);
                            });
                            
                            // Get first day of month and last day of month
                            const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
                            const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                            
                            // Get day of week of first day (0-6, where 0 is Sunday)
                            const firstDayIndex = firstDayOfMonth.getDay();
                            
                            // Add days from previous month to fill first row
                            const prevMonthLastDay = new Date(date.getFullYear(), date.getMonth(), 0).getDate();
                            for (let i = firstDayIndex - 1; i >= 0; i--) {
                                const dayElement = document.createElement('div');
                                dayElement.className = 'calendar-day other-month';
                                dayElement.textContent = prevMonthLastDay - i;
                                
                                // Add click handler
                                dayElement.addEventListener('click', () => {
                                    const selectedDate = new Date(date.getFullYear(), date.getMonth() - 1, prevMonthLastDay - i);
                                    showTimeTable(calendarElement, selectedDate);
                                });
                                
                                grid.appendChild(dayElement);
                            }
                            
                            // Add days of current month
                            const today = new Date();
                            for (let i = 1; i <= lastDayOfMonth.getDate(); i++) {
                                const dayElement = document.createElement('div');
                                dayElement.className = 'calendar-day';
                                
                                // Check if this day is today
                                if (date.getFullYear() === today.getFullYear() && 
                                    date.getMonth() === today.getMonth() && 
                                    i === today.getDate()) {
                                    dayElement.classList.add('today');
                                }
                                
                                // Check if this day has events
                                const currentDate = new Date(date.getFullYear(), date.getMonth(), i);
                                const hasEvents = calendarData.events.some(event => {
                                    const eventDate = new Date(event.date);
                                    return eventDate.getFullYear() === currentDate.getFullYear() &&
                                           eventDate.getMonth() === currentDate.getMonth() &&
                                           eventDate.getDate() === currentDate.getDate();
                                });
                                
                                if (hasEvents) {
                                    dayElement.classList.add('has-events');
                                }
                                
                                dayElement.textContent = i;
                                
                                // Add click handler
                                dayElement.addEventListener('click', () => {
                                    const selectedDate = new Date(date.getFullYear(), date.getMonth(), i);
                                    showTimeTable(calendarElement, selectedDate);
                                });
                                
                                grid.appendChild(dayElement);
                            }
                            
                            // Add days from next month to fill remaining cells
                            const totalCellsNeeded = Math.ceil((firstDayIndex + lastDayOfMonth.getDate()) / 7) * 7;
                            const nextMonthDays = totalCellsNeeded - (firstDayIndex + lastDayOfMonth.getDate());
                            
                            for (let i = 1; i <= nextMonthDays; i++) {
                                const dayElement = document.createElement('div');
                                dayElement.className = 'calendar-day other-month';
                                dayElement.textContent = i;
                                
                                // Add click handler
                                dayElement.addEventListener('click', () => {
                                    const selectedDate = new Date(date.getFullYear(), date.getMonth() + 1, i);
                                    showTimeTable(calendarElement, selectedDate);
                                });
                                
                                grid.appendChild(dayElement);
                            }
                        };
                        
                        // Function to show timetable for a specific date
                        const showTimeTable = (calendarElement, date) => {
                            const timetable = calendarElement.querySelector(`#calendar-timetable-${calendarId}`);
                            calendarData.selectedDate = date;
                            
                            // Format date
                            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                            const formattedDate = date.toLocaleDateString('en-US', options);
                            
                            // Get events for this date
                            const events = calendarData.events.filter(event => {
                                const eventDate = new Date(event.date);
                                return eventDate.getFullYear() === date.getFullYear() &&
                                       eventDate.getMonth() === date.getMonth() &&
                                       eventDate.getDate() === date.getDate();
                            });
                            
                            // Create timetable HTML
                            let timetableHtml = `
                                <div class="timetable-header">
                                    <div class="timetable-date">${formattedDate}</div>
                                </div>
                                <div class="timetable-hours">
                            `;
                            
                            // Add hours (8AM - 8PM)
                            for (let hour = 8; hour <= 20; hour++) {
                                const hourLabel = hour > 12 ? `${hour - 12}PM` : hour === 12 ? '12PM' : `${hour}AM`;
                                
                                // Find events for this hour
                                const hourEvents = events.filter(event => {
                                    const eventDate = new Date(event.date);
                                    return eventDate.getHours() === hour;
                                });
                                
                                timetableHtml += `
                                    <div class="timetable-hour">
                                        <div class="timetable-time">${hourLabel}</div>
                                        <div class="timetable-event-container">
                                            ${hourEvents.map(event => `
                                                <div class="timetable-event" style="background-color: ${event.color || '#7b3eab'}">
                                                    ${event.title}
                                                </div>
                                            `).join('')}
                                            <button class="timetable-add-btn" data-hour="${hour}">
                                                <i class="fas fa-plus"></i>
                                            </button>
                                        </div>
                                    </div>
                                `;
                            }
                            
                            timetableHtml += '</div>';
                            timetable.innerHTML = timetableHtml;
                            timetable.classList.add('active');
                            
                            // Add event listeners to add buttons
                            const addButtons = timetable.querySelectorAll('.timetable-add-btn');
                            addButtons.forEach(button => {
                                button.addEventListener('click', () => {
                                    // Set the date and time in the event editor form
                                    const hour = parseInt(button.dataset.hour);
                                    
                                    // Format date for input
                                    const dateStr = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
                                    
                                    // Format time
                                    const timeStr = `${hour.toString().padStart(2, '0')}:00`;
                                    
                                    // Set values in event editor form
                                    document.getElementById('eventDate').value = dateStr;
                                    document.getElementById('eventTime').value = timeStr;
                                    
                                    // Show event editor modal
                                    eventEditorModal.style.display = 'flex';
                                });
                            });
                        };
                        
                        // Function to add a new event
                        const addEvent = (event) => {
                            calendarData.events.push(event);
                            
                            // If the event is for the currently selected date, refresh the timetable
                            if (calendarData.selectedDate) {
                                const eventDate = new Date(event.date);
                                if (eventDate.getFullYear() === calendarData.selectedDate.getFullYear() &&
                                    eventDate.getMonth() === calendarData.selectedDate.getMonth() &&
                                    eventDate.getDate() === calendarData.selectedDate.getDate()) {
                                    const calendarElement = contentElement.closest('.calendar-widget');
                                    showTimeTable(calendarElement, calendarData.selectedDate);
                                }
                            }
                            
                            // Refresh the calendar view
                            renderCalendar(contentElement, calendarData.currentDate);
                            
                            // Save the widget state
                            const widget = contentElement.closest('.widget');
                            if (widget) {
                                saveWidgetToDatabase(widget);
                            }
                        };
                        
                        // Add event listeners for prev/next month buttons
                        contentElement.querySelector('#prev-month').addEventListener('click', () => {
                            calendarData.currentDate = new Date(calendarData.currentDate.getFullYear(), calendarData.currentDate.getMonth() - 1, 1);
                            renderCalendar(contentElement, calendarData.currentDate);
                        });
                        
                        contentElement.querySelector('#next-month').addEventListener('click', () => {
                            calendarData.currentDate = new Date(calendarData.currentDate.getFullYear(), calendarData.currentDate.getMonth() + 1, 1);
                            renderCalendar(contentElement, calendarData.currentDate);
                        });
                        
                        // Initialize the event editor form submit handler
                        eventEditorForm.addEventListener('submit', (e) => {
                            e.preventDefault();
                            
                            // Get form values
                            const title = document.getElementById('eventTitle').value;
                            const dateStr = document.getElementById('eventDate').value;
                            const timeStr = document.getElementById('eventTime').value;
                            const duration = parseInt(document.getElementById('eventDuration').value);
                            const color = document.getElementById('eventColor').value;
                            
                            // Create JavaScript date object
                            const date = new Date(`${dateStr}T${timeStr}`);
                            
                            // Create event object
                            const event = {
                                title,
                                date,
                                duration,
                                color
                            };
                            
                            // Add event to calendar
                            addEvent(event);
                            
                            // Close modal
                            eventEditorModal.style.display = 'none';
                            
                            // Show notification
                            showNotification('Event added successfully');
                        });
                        
                        // Render the initial calendar
                        renderCalendar(contentElement, calendarData.currentDate);
                        break;
                        
                    case 'pomodoro':
                        // Load custom content if available
                        if (customContent) {
                            if (customContent.workTime) pomodoroData.workTime = customContent.workTime;
                            if (customContent.breakTime) pomodoroData.breakTime = customContent.breakTime;
                            if (customContent.longBreakTime) pomodoroData.longBreakTime = customContent.longBreakTime;
                        }
                        
                        // Reset timer to work time
                        pomodoroData.timeLeft = pomodoroData.workTime * 60;
                        
                        // Create pomodoro timer HTML
                        contentElement.innerHTML = `
                            <div class="pomodoro-phase">Work Time</div>
                            <div class="pomodoro-timer">25:00</div>
                            <div class="pomodoro-progress">
                                <div class="pomodoro-progress-bar"></div>
                            </div>
                            <div class="pomodoro-controls">
                                <button class="pomodoro-btn" id="pomodoro-start">Start</button>
                                <button class="pomodoro-btn" id="pomodoro-reset">Reset</button>
                                <button class="pomodoro-btn" id="pomodoro-settings"><i class="fas fa-cog"></i></button>
                            </div>
                            <div class="pomodoro-stats">
                                <div class="pomodoro-stat">
                                    <div class="pomodoro-stat-value">0</div>
                                    <div>Completed</div>
                                </div>
                            </div>
                            <div class="pomodoro-settings" id="pomodoro-settings-panel">
                                <div class="pomodoro-input-group">
                                    <label>Work: </label>
                                    <input type="number" class="pomodoro-input work-minutes" value="${pomodoroData.workTime}" min="1" max="60">
                                    <span>min</span>
                                </div>
                                <div class="pomodoro-input-group">
                                    <label>Break: </label>
                                    <input type="number" class="pomodoro-input break-minutes" value="${pomodoroData.breakTime}" min="1" max="30">
                                    <span>min</span>
                                </div>
                                <div class="pomodoro-input-group">
                                    <label>Long Break: </label>
                                    <input type="number" class="pomodoro-input long-break-minutes" value="${pomodoroData.longBreakTime}" min="1" max="60">
                                    <span>min</span>
                                </div>
                                <button class="pomodoro-btn" id="pomodoro-save-settings">Save</button>
                            </div>
                        `;
                        
                        // Format time function
                        const formatTime = (seconds) => {
                            const mins = Math.floor(seconds / 60);
                            const secs = seconds % 60;
                            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                        };
                        
                        // Update timer display
                        const updatePomodoroDisplay = () => {
                            const timerElement = contentElement.querySelector('.pomodoro-timer');
                            const phaseElement = contentElement.querySelector('.pomodoro-phase');
                            const progressBar = contentElement.querySelector('.pomodoro-progress-bar');
                            
                            // Update time
                            timerElement.textContent = formatTime(pomodoroData.timeLeft);
                            
                            // Update phase
                            phaseElement.textContent = `${pomodoroData.currentPhase === 'work' 
                                ? 'Work Time' 
                                : pomodoroData.currentPhase === 'break' 
                                    ? 'Break Time' 
                                    : 'Long Break Time'}`;
                            
                            // Update progress bar
                            let totalTime;
                            switch (pomodoroData.currentPhase) {
                                case 'work':
                                    totalTime = pomodoroData.workTime * 60;
                                    break;
                                case 'break':
                                    totalTime = pomodoroData.breakTime * 60;
                                    break;
                                case 'longBreak':
                                    totalTime = pomodoroData.longBreakTime * 60;
                                    break;
                            }
                            
                            const progress = ((totalTime - pomodoroData.timeLeft) / totalTime) * 100;
                            progressBar.style.width = `${progress}%`;
                        };
                        
                        // Start pomodoro timer
                        const startPomodoro = () => {
                            if (pomodoroData.isRunning) return;
                            
                            pomodoroData.isRunning = true;
                            contentElement.querySelector('#pomodoro-start').textContent = 'Pause';
                            
                            pomodoroData.interval = setInterval(() => {
                                if (pomodoroData.timeLeft > 0) {
                                    pomodoroData.timeLeft--;
                                    updatePomodoroDisplay();
                                } else {
                                    // Time's up, change phase
                                    clearInterval(pomodoroData.interval);
                                    
                                    // Play notification sound
                                    try {
                                        const audio = new Audio('/static/sounds/bell.mp3');
                                        audio.play();
                                    } catch (error) {
                                        console.error('Error playing sound:', error);
                                    }
                                    
                                    // Show notification
                                    showNotification(`${pomodoroData.currentPhase === 'work' 
                                        ? 'Work time is over! Take a break.' 
                                        : 'Break time is over! Back to work.'}`);
                                    
                                    // Switch phase
                                    if (pomodoroData.currentPhase === 'work') {
                                        // Increment completed pomodoros
                                        pomodoroData.completedPomodoros++;
                                        
                                        // Update stats
                                        contentElement.querySelector('.pomodoro-stat-value').textContent = 
                                            pomodoroData.completedPomodoros;
                                        
                                        // After every 4 pomodoros, take a long break
                                        if (pomodoroData.completedPomodoros % 4 === 0) {
                                            pomodoroData.currentPhase = 'longBreak';
                                            pomodoroData.timeLeft = pomodoroData.longBreakTime * 60;
                                        } else {
                                            pomodoroData.currentPhase = 'break';
                                            pomodoroData.timeLeft = pomodoroData.breakTime * 60;
                                        }
                                    } else {
                                        pomodoroData.currentPhase = 'work';
                                        pomodoroData.timeLeft = pomodoroData.workTime * 60;
                                    }
                                    
                                    updatePomodoroDisplay();
                                    
                                    // Auto-start next phase
                                    pomodoroData.isRunning = false;
                                    startPomodoro();
                                }
                            }, 1000);
                        };
                        
                        // Pause pomodoro timer
                        const pausePomodoro = () => {
                            if (!pomodoroData.isRunning) return;
                            
                            clearInterval(pomodoroData.interval);
                            pomodoroData.isRunning = false;
                            contentElement.querySelector('#pomodoro-start').textContent = 'Start';
                        };
                        
                        // Reset pomodoro timer
                        const resetPomodoro = () => {
                            pausePomodoro();
                            pomodoroData.currentPhase = 'work';
                            pomodoroData.timeLeft = pomodoroData.workTime * 60;
                            updatePomodoroDisplay();
                        };
                        
                        // Add event listeners
                        contentElement.querySelector('#pomodoro-start').addEventListener('click', () => {
                            if (pomodoroData.isRunning) {
                                pausePomodoro();
                            } else {
                                startPomodoro();
                            }
                        });
                        
                        contentElement.querySelector('#pomodoro-reset').addEventListener('click', resetPomodoro);
                        
                        contentElement.querySelector('#pomodoro-settings').addEventListener('click', () => {
                            contentElement.querySelector('#pomodoro-settings-panel').classList.toggle('active');
                        });
                        
                        contentElement.querySelector('#pomodoro-save-settings').addEventListener('click', () => {
                            // Get new values
                            const workTime = parseInt(contentElement.querySelector('.work-minutes').value);
                            const breakTime = parseInt(contentElement.querySelector('.break-minutes').value);
                            const longBreakTime = parseInt(contentElement.querySelector('.long-break-minutes').value);
                            
                            // Validate values
                            if (workTime < 1 || breakTime < 1 || longBreakTime < 1) {
                                showNotification('Times must be at least 1 minute');
                                return;
                            }
                            
                            // Update pomodoro data
                            pomodoroData.workTime = workTime;
                            pomodoroData.breakTime = breakTime;
                            pomodoroData.longBreakTime = longBreakTime;
                            
                            // If not running, reset timer to work time
                            if (!pomodoroData.isRunning) {
                                pomodoroData.timeLeft = pomodoroData.workTime * 60;
                                updatePomodoroDisplay();
                            }
                            
                            // Hide settings panel
                            contentElement.querySelector('#pomodoro-settings-panel').classList.remove('active');
                            
                            // Save widget state
                            const widget = contentElement.closest('.widget');
                            if (widget) {
                                saveWidgetToDatabase(widget);
                            }
                            
                            showNotification('Pomodoro settings saved');
                        });
                        
                        // Initialize display
                        updatePomodoroDisplay();
                        break;
                        
                        case 'timer':
                            // Create timer HTML - Ensures timer display is FIRST for responsive design
                            contentElement.innerHTML = `
                                <div class="timer-display">00:00:00</div>
                                <div class="timer-controls">
                                    <button class="timer-btn" id="timer-start">Start</button>
                                    <button class="timer-btn" id="timer-reset">Reset</button>
                                </div>
                                <div class="timer-setup">
                                    <input type="number" class="timer-input" id="timer-hours" min="0" max="24" value="0">
                                    <span class="timer-label">h</span>
                                    <input type="number" class="timer-input" id="timer-minutes" min="0" max="59" value="0">
                                    <span class="timer-label">m</span>
                                    <input type="number" class="timer-input" id="timer-seconds" min="0" max="59" value="0">
                                    <span class="timer-label">s</span>
                                </div>
                                <div class="timer-presets">
                                    <button class="timer-preset" data-time="60">1m</button>
                                    <button class="timer-preset" data-time="300">5m</button>
                                    <button class="timer-preset" data-time="600">10m</button>
                                    <button class="timer-preset" data-time="1800">30m</button>
                                    <button class="timer-preset" data-time="3600">1h</button>
                                </div>
                            `;
                            
                            // Timer data
                            const timerData = {
                                totalSeconds: 0,
                                isRunning: false,
                                interval: null,
                                endTime: null
                            };
                            
                            // Format time for timer display
                            const formatTimerDisplay = (totalSeconds) => {
                                const hours = Math.floor(totalSeconds / 3600);
                                const minutes = Math.floor((totalSeconds % 3600) / 60);
                                const seconds = totalSeconds % 60;
                                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                            };
                            
                            // Update timer display
                            const updateTimerDisplay = () => {
                                contentElement.querySelector('.timer-display').textContent = formatTimerDisplay(timerData.totalSeconds);
                            };
                            
                            // Start timer
                            const startTimer = () => {
                                if (timerData.isRunning) return;
                                
                                // If timer is at 0, set from inputs
                                if (timerData.totalSeconds === 0) {
                                    const hours = parseInt(contentElement.querySelector('#timer-hours').value) || 0;
                                    const minutes = parseInt(contentElement.querySelector('#timer-minutes').value) || 0;
                                    const seconds = parseInt(contentElement.querySelector('#timer-seconds').value) || 0;
                                    
                                    timerData.totalSeconds = hours * 3600 + minutes * 60 + seconds;
                                    
                                    if (timerData.totalSeconds === 0) {
                                        showNotification('Please set a time first');
                                        return;
                                    }
                                }
                                
                                // Calculate end time
                                timerData.endTime = new Date().getTime() + timerData.totalSeconds * 1000;
                                
                                timerData.isRunning = true;
                                contentElement.querySelector('#timer-start').textContent = 'Pause';
                                
                                // Disable inputs
                                contentElement.querySelector('#timer-hours').disabled = true;
                                contentElement.querySelector('#timer-minutes').disabled = true;
                                contentElement.querySelector('#timer-seconds').disabled = true;
                                
                                timerData.interval = setInterval(() => {
                                    if (timerData.totalSeconds > 0) {
                                        timerData.totalSeconds--;
                                        updateTimerDisplay();
                                    } else {
                                        // Timer completed
                                        clearInterval(timerData.interval);
                                        timerData.isRunning = false;
                                        contentElement.querySelector('#timer-start').textContent = 'Start';
                                        
                                        // Enable inputs
                                        contentElement.querySelector('#timer-hours').disabled = false;
                                        contentElement.querySelector('#timer-minutes').disabled = false;
                                        contentElement.querySelector('#timer-seconds').disabled = false;
                                        
                                        // Play notification sound
                                        try {
                                            const audio = new Audio('/static/sounds/alarm.mp3');
                                            audio.play();
                                        } catch (error) {
                                            console.error('Error playing sound:', error);
                                        }
                                        
                                        showNotification('Timer completed!');
                                    }
                                }, 1000);
                            };
                            
                            // Pause timer
                            const pauseTimer = () => {
                                if (!timerData.isRunning) return;
                                
                                clearInterval(timerData.interval);
                                timerData.isRunning = false;
                                contentElement.querySelector('#timer-start').textContent = 'Start';
                            };
                            
                            // Reset timer
                            const resetTimer = () => {
                                pauseTimer();
                                timerData.totalSeconds = 0;
                                updateTimerDisplay();
                                
                                // Enable inputs
                                contentElement.querySelector('#timer-hours').disabled = false;
                                contentElement.querySelector('#timer-minutes').disabled = false;
                                contentElement.querySelector('#timer-seconds').disabled = false;
                                
                                // Reset input values
                                contentElement.querySelector('#timer-hours').value = 0;
                                contentElement.querySelector('#timer-minutes').value = 0;
                                contentElement.querySelector('#timer-seconds').value = 0;
                            };
                            
                            // Add event listeners
                            contentElement.querySelector('#timer-start').addEventListener('click', () => {
                                if (timerData.isRunning) {
                                    pauseTimer();
                                } else {
                                    startTimer();
                                }
                            });
                            
                            contentElement.querySelector('#timer-reset').addEventListener('click', resetTimer);
                            
                            // Add preset button handlers
                            contentElement.querySelectorAll('.timer-preset').forEach(button => {
                                button.addEventListener('click', () => {
                                    if (timerData.isRunning) return;
                                    
                                    const seconds = parseInt(button.dataset.time);
                                    timerData.totalSeconds = seconds;
                                    
                                    // Update input fields
                                    const hours = Math.floor(seconds / 3600);
                                    const minutes = Math.floor((seconds % 3600) / 60);
                                    const remainingSeconds = seconds % 60;
                                    
                                    contentElement.querySelector('#timer-hours').value = hours;
                                    contentElement.querySelector('#timer-minutes').value = minutes;
                                    contentElement.querySelector('#timer-seconds').value = remainingSeconds;
                                    
                                    updateTimerDisplay();
                                });
                            });
                            
                            // Apply initial responsive styling
                            setTimeout(() => {
                                const timerWidget = contentElement.closest('.widget');
                                if (timerWidget) {
                                    const width = parseInt(timerWidget.style.width) || timerWidget.offsetWidth;
                                    const height = parseInt(timerWidget.style.height) || timerWidget.offsetHeight;
                                    handleTimerResponsive(timerWidget, width, height);
                                }
                            }, 100);
                            
                            break;
                        
                    case 'pet':
                        // Load custom data if available
                        if (customContent) {
                            if (customContent.petType) petData.type = customContent.petType;
                            if (customContent.petName) petData.name = customContent.petName;
                            if (customContent.petHunger) petData.hunger = customContent.petHunger;
                            if (customContent.petHappiness) petData.happiness = customContent.petHappiness;
                            if (customContent.petEnergy) petData.energy = customContent.petEnergy;
                        }
                        
                        // Create pet HTML
                        contentElement.innerHTML = `
                            <div class="pet-container">
                                <img src="/static/assets/pets/cat_idle_1.png" class="pet-sprite" data-pet-type="${petData.type}">
                                <div class="pet-message"></div>
                            </div>
                            <div class="pet-name">${petData.name}</div>
                            <div class="pet-status">
                                <div class="pet-stat">
                                    <div class="pet-stat-label">Hunger</div>
                                    <div class="pet-stat-bar">
                                        <div class="pet-stat-fill hunger-fill" style="width: ${petData.hunger}%"></div>
                                    </div>
                                </div>
                                <div class="pet-stat">
                                    <div class="pet-stat-label">Happiness</div>
                                    <div class="pet-stat-bar">
                                        <div class="pet-stat-fill happiness-fill" style="width: ${petData.happiness}%"></div>
                                    </div>
                                </div>
                                <div class="pet-stat">
                                    <div class="pet-stat-label">Energy</div>
                                    <div class="pet-stat-bar">
                                        <div class="pet-stat-fill energy-fill" style="width: ${petData.energy}%"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="pet-actions">
                                <button class="pet-btn" id="pet-feed">Feed</button>
                                <button class="pet-btn" id="pet-play">Play</button>
                                <button class="pet-btn" id="pet-sleep">Sleep</button>
                            </div>
                        `;
                        
                        // Update pet animation
                        let currentFrameIndex = 0;
                        
                        const updatePetAnimation = () => {
                            const petSprite = contentElement.querySelector('.pet-sprite');
                            const currentAnimFrames = petData.animations[petData.currentState];
                            
                            if (!currentAnimFrames || currentAnimFrames.length === 0) return;
                            
                            petSprite.src = `/static/assets/pets/${currentAnimFrames[currentFrameIndex]}`;
                            currentFrameIndex = (currentFrameIndex + 1) % currentAnimFrames.length;
                        };
                        
                        // Start animation loop
                        const animInterval = setInterval(updatePetAnimation, 500); // Change frame every 500ms
                        
                        // Show a message from pet
                        const showPetMessage = (message) => {
                            const messageElement = contentElement.querySelector('.pet-message');
                            messageElement.textContent = message;
                            messageElement.classList.add('active');
                            
                            setTimeout(() => {
                                messageElement.classList.remove('active');
                            }, 3000);
                        };
                        
                        // Start stat decrease over time
                        const decreaseStats = () => {
                            // Only decrease if not already at minimum
                            if (petData.hunger > 0) petData.hunger -= 1;
                            if (petData.happiness > 0) petData.happiness -= 1;
                            if (petData.energy > 0) petData.energy -= 1;
                            
                            // Update UI
                            contentElement.querySelector('.hunger-fill').style.width = `${petData.hunger}%`;
                            contentElement.querySelector('.happiness-fill').style.width = `${petData.happiness}%`;
                            contentElement.querySelector('.energy-fill').style.width = `${petData.energy}%`;
                            
                            // Show messages based on low stats
                            if (petData.hunger < 20 && petData.hunger > 0) showPetMessage("I'm hungry!");
                            if (petData.happiness < 20 && petData.happiness > 0) showPetMessage("I'm bored!");
                            if (petData.energy < 20 && petData.energy > 0) showPetMessage("I'm tired!");
                            
                            // Save pet state
                            const widget = contentElement.closest('.widget');
                            if (widget) {
                                saveWidgetToDatabase(widget);
                            }
                        };
                        
                        // Start stat decrease interval
                        petData.decreaseInterval = setInterval(decreaseStats, 60000); // Decrease every 60 seconds
                        
                        // Add action event listeners
                        contentElement.querySelector('#pet-feed').addEventListener('click', () => {
                            if (petData.currentState === 'sleeping') {
                                showPetMessage("I'm sleeping...");
                                return;
                            }
                            
                            petData.currentState = 'eating';
                            currentFrameIndex = 0;
                            updatePetAnimation();
                            
                            petData.hunger = Math.min(100, petData.hunger + 30);
                            contentElement.querySelector('.hunger-fill').style.width = `${petData.hunger}%`;
                            
                            showPetMessage("Yum! Thank you!");
                            
                            // Return to idle after 2 seconds
                            setTimeout(() => {
                                petData.currentState = 'idle';
                                currentFrameIndex = 0;
                            }, 2000);
                            
                            // Save pet state
                            const widget = contentElement.closest('.widget');
                            if (widget) {
                                saveWidgetToDatabase(widget);
                            }
                        });
                        
                        contentElement.querySelector('#pet-play').addEventListener('click', () => {
                            if (petData.currentState === 'sleeping') {
                                showPetMessage("I'm sleeping...");
                                return;
                            }
                            
                            if (petData.energy < 20) {
                                showPetMessage("I'm too tired to play!");
                                return;
                            }
                            
                            petData.currentState = 'playing';
                            currentFrameIndex = 0;
                            updatePetAnimation();
                            
                            petData.happiness = Math.min(100, petData.happiness + 30);
                            petData.energy = Math.max(0, petData.energy - 20);
                            
                            contentElement.querySelector('.happiness-fill').style.width = `${petData.happiness}%`;
                            contentElement.querySelector('.energy-fill').style.width = `${petData.energy}%`;
                            
                            showPetMessage("This is fun!");
                            
                            // Return to idle after 3 seconds
                            setTimeout(() => {
                                petData.currentState = 'idle';
                                currentFrameIndex = 0;
                            }, 3000);
                            
                            // Save pet state
                            const widget = contentElement.closest('.widget');
                            if (widget) {
                                saveWidgetToDatabase(widget);
                            }
                        });
                        
                        contentElement.querySelector('#pet-sleep').addEventListener('click', () => {
                            if (petData.currentState === 'sleeping') {
                                // Wake up
                                petData.currentState = 'idle';
                                currentFrameIndex = 0;
                                updatePetAnimation();
                                
                                contentElement.querySelector('#pet-sleep').textContent = 'Sleep';
                                showPetMessage("I'm awake!");
                                return;
                            }
                            
                            petData.currentState = 'sleeping';
                            currentFrameIndex = 0;
                            updatePetAnimation();
                            
                            contentElement.querySelector('#pet-sleep').textContent = 'Wake';
                            
                            // Increase energy while sleeping
                            const energyInterval = setInterval(() => {
                                if (petData.currentState !== 'sleeping') {
                                    clearInterval(energyInterval);
                                    return;
                                }
                                
                                petData.energy = Math.min(100, petData.energy + 10);
                                contentElement.querySelector('.energy-fill').style.width = `${petData.energy}%`;
                                
                                // Save pet state
                                const widget = contentElement.closest('.widget');
                                if (widget) {
                                    saveWidgetToDatabase(widget);
                                }
                                
                                if (petData.energy >= 100) {
                                    clearInterval(energyInterval);
                                    showPetMessage("I'm fully rested!");
                                }
                            }, 3000);
                            
                            showPetMessage("Zzz...");
                            
                            // Save pet state
                            const widget = contentElement.closest('.widget');
                            if (widget) {
                                saveWidgetToDatabase(widget);
                            }
                        });
                        
                        // Store animation interval ID for cleanup
                        contentElement.dataset.animationIntervalId = animInterval;
                        contentElement.dataset.decreaseIntervalId = petData.decreaseInterval;
                        break;
                        
                    case 'todo':
                        // Load saved todos if available
                        const savedTodos = [];
                        if (customContent && customContent.todos) {
                            savedTodos.push(...customContent.todos);
                        }
                        
                        // Create todo HTML
                        contentElement.innerHTML = `
                            <div class="todo-header">
                                <input type="text" class="todo-input" placeholder="Add a task...">
                                <button class="todo-add-btn">Add</button>
                            </div>
                            <div class="todo-list"></div>
                            <div class="todo-stats">
                                <span>Total: <span class="todo-total">0</span></span>
                                <span>Completed: <span class="todo-completed">0</span></span>
                            </div>
                        `;
                        
                        // Function to add a todo item
                        const addTodoItem = (text, completed = false) => {
                            const todoList = contentElement.querySelector('.todo-list');
                            
                            const todoItem = document.createElement('div');
                            todoItem.className = 'todo-item';
                            
                            const checkbox = document.createElement('div');
                            checkbox.className = `todo-checkbox ${completed ? 'checked' : ''}`;
                            checkbox.addEventListener('click', () => {
                                checkbox.classList.toggle('checked');
                                todoText.classList.toggle('completed');
                                updateTodoStats();
                                
                                // Save todo state
                                const widget = contentElement.closest('.widget');
                                if (widget) {
                                    saveWidgetToDatabase(widget);
                                }
                            });
                            
                            const todoText = document.createElement('div');
                            todoText.className = `todo-text ${completed ? 'completed' : ''}`;
                            todoText.textContent = text;
                            
                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'todo-delete';
                            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                            deleteBtn.addEventListener('click', () => {
                                todoList.removeChild(todoItem);
                                updateTodoStats();
                                
                                // Save todo state
                                const widget = contentElement.closest('.widget');
                                if (widget) {
                                    saveWidgetToDatabase(widget);
                                }
                            });
                            
                            todoItem.appendChild(checkbox);
                            todoItem.appendChild(todoText);
                            todoItem.appendChild(deleteBtn);
                            
                            todoList.appendChild(todoItem);
                            updateTodoStats();
                        };
                        
                        // Update todo statistics
                        const updateTodoStats = () => {
                            const totalTodos = contentElement.querySelectorAll('.todo-item').length;
                            const completedTodos = contentElement.querySelectorAll('.todo-checkbox.checked').length;
                            
                            contentElement.querySelector('.todo-total').textContent = totalTodos;
                            contentElement.querySelector('.todo-completed').textContent = completedTodos;
                        };
                        
                        // Load saved todos
                        savedTodos.forEach(todo => {
                            addTodoItem(todo.text, todo.completed);
                        });
                        
                        // Add event listener for adding todos
                        const todoInput = contentElement.querySelector('.todo-input');
                        const todoAddBtn = contentElement.querySelector('.todo-add-btn');
                        
                        const addTodo = () => {
                            const text = todoInput.value.trim();
                            if (text) {
                                addTodoItem(text);
                                todoInput.value = '';
                                
                                // Save todo state
                                const widget = contentElement.closest('.widget');
                                if (widget) {
                                    saveWidgetToDatabase(widget);
                                }
                            }
                        };
                        
                        todoAddBtn.addEventListener('click', addTodo);
                        
                        todoInput.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                addTodo();
                            }
                        });
                        break;
                        
                    case 'alarm':
                        // Load saved alarms if available
                        const savedAlarms = [];
                        if (customContent && customContent.alarms) {
                            savedAlarms.push(...customContent.alarms);
                        }
                        
                        // Create alarm HTML
                        contentElement.innerHTML = `
                            <div class="alarm-display">
                                <div class="alarm-time" id="alarm-current-time">--:--</div>
                                <div class="alarm-status" id="alarm-status">No active alarm</div>
                            </div>
                            <div class="alarm-controls">
                                <div class="alarm-input-row">
                                    <input type="number" class="alarm-input" id="alarm-hours" min="0" max="23" value="7">
                                    <span>:</span>
                                    <input type="number" class="alarm-input" id="alarm-minutes" min="0" max="59" value="0">
                                </div>
                                <button class="alarm-btn" id="alarm-set">Set Alarm</button>
                            </div>
                            <div class="alarm-list"></div>
                        `;
                        
                        // Update current time display
                        const updateAlarmTimeDisplay = () => {
                            const now = new Date();
                            const hours = now.getHours().toString().padStart(2, '0');
                            const minutes = now.getMinutes().toString().padStart(2, '0');
                            
                            contentElement.querySelector('#alarm-current-time').textContent = `${hours}:${minutes}`;
                        };
                        
                        // Check if any alarms should trigger
                        const checkAlarms = () => {
                            const now = new Date();
                            const currentHours = now.getHours();
                            const currentMinutes = now.getMinutes();
                            
                            const alarmItems = contentElement.querySelectorAll('.alarm-item');
                            alarmItems.forEach(item => {
                                if (!item.querySelector('.alarm-item-toggle').classList.contains('active')) {
                                    return;
                                }
                                
                                const timeText = item.querySelector('.alarm-item-time').textContent;
                                const [hours, minutes] = timeText.split(':').map(num => parseInt(num));
                                
                                if (hours === currentHours && minutes === currentMinutes && !alarmData.activeAlarm) {
                                    // Trigger alarm
                                    alarmData.activeAlarm = timeText;
                                    
                                    // Update status
                                    contentElement.querySelector('#alarm-status').textContent = `â° Alarm: ${timeText}`;
                                    
                                    // Play alarm sound
                                    try {
                                        const audio = new Audio('/static/sounds/alarm.mp3');
                                        audio.loop = true;
                                        audio.play();
                                        
                                        // Store audio element to stop it later
                                        alarmData.alarmAudio = audio;
                                    } catch (error) {
                                        console.error('Error playing alarm sound:', error);
                                    }
                                    
                                    // Show notification
                                    showNotification(`Alarm: ${timeText}`);
                                    
                                    // Reset active alarm after 60 seconds
                                    setTimeout(() => {
                                        if (alarmData.alarmAudio) {
                                            alarmData.alarmAudio.pause();
                                            alarmData.alarmAudio = null;
                                        }
                                        
                                        alarmData.activeAlarm = null;
                                        contentElement.querySelector('#alarm-status').textContent = 'No active alarm';
                                    }, 60000);
                                }
                            });
                        };
                        
                        // Function to add an alarm item
                        const addAlarmItem = (time, active = true) => {
                            const alarmList = contentElement.querySelector('.alarm-list');
                            
                            const alarmItem = document.createElement('div');
                            alarmItem.className = 'alarm-item';
                            
                            const timeText = document.createElement('div');
                            timeText.className = 'alarm-item-time';
                            timeText.textContent = time;
                            
                            const toggle = document.createElement('div');
                            toggle.className = `alarm-item-toggle ${active ? 'active' : ''}`;
                            toggle.addEventListener('click', () => {
                                toggle.classList.toggle('active');
                                
                                // Save alarm state
                                const widget = contentElement.closest('.widget');
                                if (widget) {
                                    saveWidgetToDatabase(widget);
                                }
                            });
                            
                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'alarm-item-delete';
                            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                            deleteBtn.addEventListener('click', () => {
                                alarmList.removeChild(alarmItem);
                                
                                // Save alarm state
                                const widget = contentElement.closest('.widget');
                                if (widget) {
                                    saveWidgetToDatabase(widget);
                                }
                            });
                            
                            alarmItem.appendChild(timeText);
                            alarmItem.appendChild(toggle);
                            alarmItem.appendChild(deleteBtn);
                            
                            alarmList.appendChild(alarmItem);
                        };
                        
                        // Start clock update and alarm check intervals
                        updateAlarmTimeDisplay();
                        const clockUpdateInterval = setInterval(updateAlarmTimeDisplay, 1000);
                        const alarmCheckInterval = setInterval(checkAlarms, 1000);
                        
                        // Store interval IDs for cleanup
                        contentElement.dataset.clockIntervalId = clockUpdateInterval;
                        contentElement.dataset.alarmIntervalId = alarmCheckInterval;
                        
                        // Add event listener for setting alarm
                        contentElement.querySelector('#alarm-set').addEventListener('click', () => {
                            const hours = parseInt(contentElement.querySelector('#alarm-hours').value).toString().padStart(2, '0');
                            const minutes = parseInt(contentElement.querySelector('#alarm-minutes').value).toString().padStart(2, '0');
                            
                            if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
                                showNotification('Please enter a valid time');
                                return;
                            }
                            
                            const time = `${hours}:${minutes}`;
                            
                            // Check if alarm already exists
                            const existingAlarm = Array.from(contentElement.querySelectorAll('.alarm-item-time'))
                                .find(element => element.textContent === time);
                                
                            if (existingAlarm) {
                                showNotification('This alarm already exists');
                                return;
                            }
                            
                            addAlarmItem(time);
                            
                            // Save alarm state
                            const widget = contentElement.closest('.widget');
                            if (widget) {
                                saveWidgetToDatabase(widget);
                            }
                            
                            showNotification(`Alarm set for ${time}`);
                        });
                        
                        // Load saved alarms
                        savedAlarms.forEach(alarm => {
                            addAlarmItem(alarm.time, alarm.active);
                        });
                        break;
                        
                    default:
                        contentElement.innerHTML = `<div>No content available for ${type} widget</div>`;
                }
            };

            // Make an element draggable
            const makeDraggable = (element) => {
                let isDragging = false;
                let startX, startY, startLeft, startTop;
                
                element.addEventListener('mousedown', (e) => {
                    // Only if left button is clicked (not right click)
                    if (e.button !== 0 || e.target.closest('.resize-handle')) return;
                    
                    isDragging = true;
                    
                    // Add active class
                    element.classList.add('widget-active');
                    
                    // Bring to front
                    Array.from(document.querySelectorAll('.widget')).forEach(w => {
                        w.style.zIndex = '1';
                    });
                    element.style.zIndex = '10';
                    
                    // Get initial positions
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(element.style.left) || 0;
                    startTop = parseInt(element.style.top) || 0;
                    
                    // Prevent default behavior
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    // Calculate new position
                    const newLeft = startLeft + (e.clientX - startX);
                    const newTop = startTop + (e.clientY - startY);
                    
                    // Update element's position
                    element.style.left = `${newLeft}px`;
                    element.style.top = `${newTop}px`;
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        element.classList.remove('widget-active');
                        
                        // Log the widget being saved after drag
                        console.log(`Saving widget after drag: Type=${element.dataset.type}, ID=${element.dataset.id}`);
                        
                        // Save position to database
                        saveWidgetToDatabase(element);
                    }
                });
            };

            // Make an element resizable
            const makeResizable = (element, handle) => {
                let isResizing = false;
                let startX, startY, startWidth, startHeight;
                
                // Widget-specific minimum dimensions
                const minDimensions = {
                    'profile': { width: 180, height: 120 },
                    'skills': { width: 150, height: 100 },
                    'github': { width: 180, height: 150 },
                    'avatar': { width: 150, height: 180 },
                    'clock': { width: 120, height: 80 },
                    'date': { width: 150, height: 80 },
                    'notes': { width: 150, height: 100 },
                    'spotify': { width: 180, height: 150 },
                    'calendar': { width: 250, height: 200 },
                    'pomodoro': { width: 180, height: 150 },
                    'pet': { width: 180, height: 180 },
                    'todo': { width: 180, height: 150 },
                    'alarm': { width: 180, height: 150 },
                    'timer': { width: 180, height: 150 },
                    'image': { width: 150, height: 120 },
                    'default': { width: 150, height: 100 }
                };
                
                // Handle mousedown to start resizing
                handle.addEventListener('mousedown', (e) => {
                    // Only if left button is clicked
                    if (e.button !== 0) return;
                    
                    isResizing = true;
                    
                    // Add active class
                    element.classList.add('widget-active');
                    
                    // Get initial positions and dimensions
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = parseInt(element.style.width) || element.offsetWidth;
                    startHeight = parseInt(element.style.height) || element.offsetHeight;
                    
                    // Prevent default behavior
                    e.preventDefault();
                });
                
                // Handle mousemove to resize
                const handleResize = (e) => {
                    if (!isResizing) return;
                    
                    // Calculate new dimensions
                    const newWidth = startWidth + (e.clientX - startX);
                    const newHeight = startHeight + (e.clientY - startY);
                    
                    // Get widget type and minimum dimensions
                    const widgetType = element.dataset.type || 'default';
                    const minWidth = minDimensions[widgetType]?.width || minDimensions.default.width;
                    const minHeight = minDimensions[widgetType]?.height || minDimensions.default.height;
                    
                    // Special case for avatar and image widgets
                    if (widgetType === 'avatar' || widgetType === 'image') {
                        const img = element.querySelector('.current-voxel-avatar, .widget-content img');
                        if (img) {
                            // Get natural aspect ratio of the image
                            const imgRatio = (img.naturalWidth / img.naturalHeight) || 0.8;
                            
                            // Enforce aspect ratio during resizing for avatar/image widgets
                            if (newWidth >= minWidth && newHeight >= minHeight) {
                                if (newWidth / newHeight > imgRatio) {
                                    // Too wide, adjust width based on height
                                    element.style.height = `${newHeight}px`;
                                    element.style.width = `${newHeight * imgRatio}px`;
                                } else {
                                    // Too tall, adjust height based on width
                                    element.style.width = `${newWidth}px`;
                                    element.style.height = `${newWidth / imgRatio}px`;
                                }
                            }
                            return; // Skip standard resizing
                        }
                    }
                    
                    // Update dimensions if above minimum
                    if (newWidth >= minWidth) {
                        element.style.width = `${newWidth}px`;
                    }
                    
                    if (newHeight >= minHeight) {
                        element.style.height = `${newHeight}px`;
                    }
                    
                    // Ensure widget stays within dashboard bounds
                    const dashboardBounds = document.getElementById('dashboardArea').getBoundingClientRect();
                    const widgetRect = element.getBoundingClientRect();
                    
                    if (widgetRect.right > dashboardBounds.right) {
                        element.style.width = `${dashboardBounds.right - widgetRect.left}px`;
                    }
                    
                    if (widgetRect.bottom > dashboardBounds.bottom) {
                        element.style.height = `${dashboardBounds.bottom - widgetRect.top}px`;
                    }
                };
                
                // Use a separate throttled event handler for move events
                let lastMoveTime = 0;
                document.addEventListener('mousemove', (e) => {
                    const now = Date.now();
                    if (now - lastMoveTime > 16) { // Throttle to ~60fps
                        lastMoveTime = now;
                        handleResize(e);
                    }
                });
                
                // Handle mouseup to stop resizing
                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        element.classList.remove('widget-active');
                        
                        // Update responsive display based on new size
                        updateWidgetResponsiveDisplay(element);
                        
                        // Log the widget being saved after resize
                        console.log(`Saving widget after resize: Type=${element.dataset.type}, ID=${element.dataset.id}`);
                        
                        // Save dimensions to database
                        saveWidgetToDatabase(element);
                    }
                });
            };

            // Background and Dashboard Settings
            // Initialize background settings tabs
            document.querySelectorAll('.background-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs
                    document.querySelectorAll('.background-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.background-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show corresponding content
                    const contentId = tab.dataset.tab;
                    document.querySelector(`.background-content[data-content="${contentId}"]`).classList.add('active');
                });
            });
            
            // Background color selection
            document.querySelectorAll('#backgroundSettings .color-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    document.querySelectorAll('#backgroundSettings .color-option').forEach(opt => opt.classList.remove('selected'));
                    
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    
                    // Update custom color input
                    document.getElementById('customColorInput').value = option.dataset.color;
                });
            });
            
            // Widget color selection
            document.querySelectorAll('#widgetColorSettings .color-option').forEach(option => {
                option.addEventListener('click', function() {
                    // Determine which tab is active (bg or text)
                    const activeTab = document.querySelector('#widgetColorSettings .background-tab.active').dataset.tab;
                    
                    // Remove selected class from options in this tab
                    const targetSelector = activeTab === 'widget-bg' ? '#customWidgetBgInput' : '#customWidgetTextInput';
                    document.querySelectorAll(`#widgetColorSettings .background-content[data-content="${activeTab}"] .color-option`)
                        .forEach(opt => opt.classList.remove('selected'));
                    
                    // Add selected class
                    option.classList.add('selected');
                    
                    // Update custom color input
                    document.querySelector(targetSelector).value = option.dataset.color;
                });
            });
            
            // Image upload for background
            document.getElementById('bgImageUpload').addEventListener('change', function(e) {
                if (this.files && this.files[0]) {
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        // Update preview
                        document.getElementById('bgImagePreview').style.backgroundImage = `url(${e.target.result})`;
                    };
                    
                    reader.readAsDataURL(this.files[0]);
                }
            });
            
            // Apply background settings
            document.getElementById('applyBgSettings').addEventListener('click', () => {
                const activeTab = document.querySelector('#backgroundSettings .background-tab.active').dataset.tab;
                let backgroundType, backgroundValue;
                
                if (activeTab === 'color') {
                    // Apply color background
                    backgroundType = 'color';
                    backgroundValue = document.getElementById('customColorInput').value;
                    
                    // Set background
                    dashboardArea.style.backgroundImage = 'none';
                    dashboardArea.style.backgroundColor = backgroundValue;
                    
                    // Save settings to server
                    saveDashboardSettings(backgroundType, backgroundValue);
                    
                    // Close settings panel
                    backgroundSettings.style.display = 'none';
                } else if (activeTab === 'image') {
                    // Apply image background
                    backgroundType = 'image';
                    
                    // Get selected image
                    const fileInput = document.getElementById('bgImageUpload');
                    if (fileInput.files && fileInput.files[0]) {
                        console.log("Uploading background image...");
                        // Upload to server
                        const formData = new FormData();
                        formData.append('image', fileInput.files[0]);
                        
                        fetch('/upload-image', {
                            method: 'POST',
                            body: formData
                        })
                        .then(response => response.json())
                        .then(data => {
                            console.log("Background upload response:", data);
                            if (data.success) {
                                backgroundValue = data.image_url;
                                
                                // Set background
                                dashboardArea.style.backgroundColor = 'transparent';
                                dashboardArea.style.backgroundImage = `url(${backgroundValue})`;
                                
                                // Save settings to server
                                console.log("Saving background settings:", {
                                    type: backgroundType,
                                    value: backgroundValue
                                });
                                saveDashboardSettings(backgroundType, backgroundValue);
                                
                                // Close settings panel after successful save
                                backgroundSettings.style.display = 'none';
                                
                                // Show success notification
                                showNotification("Background updated successfully!");
                            } else {
                                showNotification(`Failed to upload image: ${data.message}`);
                            }
                        })
                        .catch(error => {
                            console.error('Error uploading background image:', error);
                            showNotification('Error uploading background image');
                        });
                    } else {
                        // No file selected, handle existing background
                        backgroundValue = dashboardArea.style.backgroundImage;
                        if (backgroundValue.startsWith('url(')) {
                            backgroundValue = backgroundValue.substring(4, backgroundValue.length - 1).replace(/"/g, '');
                            
                            // Save settings to server
                            console.log("Keeping existing background:", backgroundValue);
                            saveDashboardSettings(backgroundType, backgroundValue);
                        } else {
                            console.log("No background image selected or currently set");
                        }
                        
                        // Close settings panel
                        backgroundSettings.style.display = 'none';
                    }
                }
            });
            
            // Cancel background settings
            document.getElementById('cancelBgSettings').addEventListener('click', () => {
                backgroundSettings.style.display = 'none';
            });
            
            // Apply widget color settings
            document.getElementById('applyWidgetColorSettings').addEventListener('click', () => {
                const bgColor = document.getElementById('customWidgetBgInput').value;
                const textColor = document.getElementById('customWidgetTextInput').value;
                
                // Send to server
                fetch('/update-all-widgets-color', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        bg_color: bgColor,
                        text_color: textColor
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showNotification(`Updated ${data.modified_count} widgets`);
                        
                        // Update all widgets in the DOM
                        document.querySelectorAll('.widget').forEach(widget => {
                            if (bgColor) widget.style.backgroundColor = bgColor;
                            if (textColor) widget.style.color = textColor;
                        });
                    } else {
                        showNotification(`Failed to update widgets: ${data.message}`);
                    }
                })
                .catch(error => {
                    console.error('Error updating widgets:', error);
                    showNotification('Error updating widgets');
                });
                
                // Close settings panel
                widgetColorSettings.style.display = 'none';
            });
            
            // Cancel widget color settings
            document.getElementById('cancelWidgetColorSettings').addEventListener('click', () => {
                widgetColorSettings.style.display = 'none';
            });
            
            // Create dynamic color picker
            function createAndShowColorPicker(target, widgetId) {
                // Remove any existing dynamic color pickers
                const existingPicker = document.getElementById('dynamicColorPicker');
                if (existingPicker) {
                    document.body.removeChild(existingPicker);
                }
                
                // Create a new color picker
                const pickerDiv = document.createElement('div');
                pickerDiv.id = 'dynamicColorPicker';
                pickerDiv.style.position = 'fixed';
                pickerDiv.style.left = '50%';
                pickerDiv.style.top = '50%';
                pickerDiv.style.transform = 'translate(-50%, -50%)';
                pickerDiv.style.backgroundColor = '#ffffff';
                pickerDiv.style.border = '2px solid #000000';
                pickerDiv.style.borderRadius = '0';
                pickerDiv.style.padding = '15px';
                pickerDiv.style.zIndex = '9999';
                pickerDiv.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
                pickerDiv.style.fontFamily = "'Press Start 2P', monospace";
                pickerDiv.style.fontSize = '0.7rem';
                
                // Add a title
                const title = document.createElement('div');
                title.style.marginBottom = '10px';
                title.style.fontWeight = 'bold';
                title.textContent = target === 'background' ? 'Select Background Color' : 'Select Text Color';
                pickerDiv.appendChild(title);
                
                // Create color grid
                const colorGrid = document.createElement('div');
                colorGrid.style.display = 'grid';
                colorGrid.style.gridTemplateColumns = 'repeat(5, 1fr)';
                colorGrid.style.gap = '10px';
                
                // Define colors
                const colors = [
                    '#ffffff', '#000000', '#f0f0f0', '#333333', '#7b3eab',
                    '#3f51b5', '#009688', '#4caf50', '#ffc107', '#ff5722'
                ];
                
                // Add color options
                colors.forEach(color => {
                    const colorOption = document.createElement('div');
                    colorOption.style.width = '30px';
                    colorOption.style.height = '30px';
                    colorOption.style.backgroundColor = color;
                    colorOption.style.border = '1px solid #000000';
                    colorOption.style.cursor = 'pointer';
                    colorOption.style.transition = 'transform 0.2s';
                    
                    // Hover effect
                    colorOption.onmouseover = () => {
                        colorOption.style.transform = 'scale(1.1)';
                    };
                    colorOption.onmouseout = () => {
                        colorOption.style.transform = 'scale(1)';
                    };
                    
                    // Click handler
                    colorOption.onclick = () => {
                        const widget = document.querySelector(`[data-id="${widgetId}"]`);
                        if (!widget) {
                            console.error(`Widget not found: ${widgetId}`);
                            return;
                        }
                        
                        // Apply color
                        if (target === 'background') {
                            widget.style.backgroundColor = color;
                            // Adjust text color for readability
                            if (color === '#000000' || color === '#333333') {
                                widget.style.color = '#ffffff';
                            } else {
                                widget.style.color = '#000000';
                            }
                        } else if (target === 'text') {
                            widget.style.color = color;
                        }
                        
                        // Save widget changes
                        saveWidgetToDatabase(widget);
                        
                        // Close color picker
                        document.body.removeChild(pickerDiv);
                        
                        // Show notification
                        showNotification(`Widget ${target} color updated`);
                    };
                    
                    colorGrid.appendChild(colorOption);
                });
                
                pickerDiv.appendChild(colorGrid);
                
                // Add close button
                const closeBtn = document.createElement('button');
                closeBtn.textContent = 'Close';
                closeBtn.style.marginTop = '15px';
                closeBtn.style.padding = '5px 10px';
                closeBtn.style.backgroundColor = '#000000';
                closeBtn.style.color = '#ffffff';
                closeBtn.style.border = 'none';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.fontFamily = "'Press Start 2P', monospace";
                closeBtn.style.fontSize = '0.6rem';
                closeBtn.onclick = () => {
                    document.body.removeChild(pickerDiv);
                };
                
                pickerDiv.appendChild(closeBtn);
                
                // Add to document
                document.body.appendChild(pickerDiv);
                
                // Close when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', function closeHandler(e) {
                        if (!pickerDiv.contains(e.target) && e.target !== pickerDiv) {
                            if (document.body.contains(pickerDiv)) {
                                document.body.removeChild(pickerDiv);
                            }
                            document.removeEventListener('click', closeHandler);
                        }
                    });
                }, 100);
            }
            
            // Save dashboard settings to server
            function saveDashboardSettings(type, value) {
                fetch('/save-dashboard-settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        background_type: type,
                        background_value: value
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showNotification('Dashboard settings saved');
                    } else {
                        showNotification(`Failed to save settings: ${data.message}`);
                    }
                })
                .catch(error => {
                    console.error('Error saving dashboard settings:', error);
                    showNotification('Error saving dashboard settings');
                });
            }
            
            // Update widget visibility
            function updateWidgetsVisibility(widgetIds, isPublic) {
                if (!widgetIds || widgetIds.length === 0) return;
                
                fetch('/update-widgets-visibility', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        widget_ids: widgetIds,
                        is_public: isPublic
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update status in DOM
                        widgetIds.forEach(id => {
                            const widget = document.querySelector(`[data-id="${id}"]`);
                            if (widget) {
                                widget.dataset.public = isPublic.toString();
                            }
                        });
                        
                        showNotification(`Updated ${data.modified_count} widgets visibility`);
                    } else {
                        showNotification(`Failed to update widgets: ${data.message}`);
                    }
                })
                .catch(error => {
                    console.error('Error updating widgets visibility:', error);
                    showNotification('Error updating widgets visibility');
                });
            }
            
            // Show Voxel Avatar Selector
            function showVoxelAvatarSelector(widget) {
                // Create modal for avatar selection
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'flex';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                
                const header = document.createElement('div');
                header.className = 'modal-header';
                header.innerHTML = '<h2>Select Avatar</h2><button class="modal-close">&times;</button>';
                
                const body = document.createElement('div');
                body.className = 'voxel-avatar-grid';
                
                // Add avatars to grid
                voxelAvatars.forEach(avatar => {
                    const avatarItem = document.createElement('div');
                    avatarItem.className = 'voxel-avatar-item';
                    avatarItem.innerHTML = `
                        <img src="/static/assets/voxels/${avatar.file}" 
                             alt="${avatar.name}" 
                             class="voxel-avatar-option" 
                             data-voxel="${avatar.id}">
                        <div class="voxel-avatar-option-name">${avatar.name}</div>
                    `;
                    
                    // Add click handler
                    avatarItem.addEventListener('click', () => {
                        // Update widget's avatar
                        const currentAvatar = widget.querySelector('.current-voxel-avatar');
                        if (currentAvatar) {
                            currentAvatar.src = `/static/assets/voxels/${avatar.file}`;
                            currentAvatar.dataset.voxel = avatar.id;
                            currentAvatar.alt = avatar.name;
                        }
                        
                        // Update avatar name
                        const avatarName = widget.querySelector('.voxel-avatar-name');
                        if (avatarName) {
                            avatarName.textContent = avatar.name;
                        }
                        
                        // Save to user data
                        userData.voxel_avatar_id = avatar.id;
                        
                        // Save to database (optional, implement backend)
                        fetch('/update-voxel-avatar', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                voxel_avatar_id: avatar.id
                            })
                        })
                        .catch(error => console.error('Error updating avatar:', error));
                        
                        // Close modal
                        document.body.removeChild(modal);
                        
                        // Show notification
                        showNotification(`Avatar changed to ${avatar.name}`);
                    });
                    
                    body.appendChild(avatarItem);
                });
                
                modalContent.appendChild(header);
                modalContent.appendChild(body);
                modal.appendChild(modalContent);
                
                // Close button handler
                const closeBtn = header.querySelector('.modal-close');
                closeBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                
                // Add to body
                document.body.appendChild(modal);
            }
            
            // Context Menu Options
            contextMenu.addEventListener('click', function(e) {
                const option = e.target.closest('.context-menu-option');
                if (!option) return;
                
                const action = option.dataset.action;
                const widgetId = contextMenu.dataset.widgetId;
                const widget = document.querySelector(`[data-id="${widgetId}"]`);
                
                if (!widget) {
                    console.error(`Widget not found for ID: ${widgetId}`);
                    return;
                }
                
                switch(action) {
                    case 'bg-color':
                        // Use dynamic color picker
                        createAndShowColorPicker('background', widgetId);
                        break;
                        
                    case 'text-color':
                        // Use dynamic color picker
                        createAndShowColorPicker('text', widgetId);
                        break;
                        
                    case 'visibility-toggle':
                        // Toggle widget public/private status
                        const isCurrentlyPublic = widget.dataset.public === 'true';
                        const newStatus = !isCurrentlyPublic;
                        
                        // Update in database
                        updateWidgetsVisibility([widgetId], newStatus);
                        break;
                        
                    case 'resize':
                        widget.classList.toggle('resize-mode');
                        showNotification('Resize by dragging the bottom-right corner');
                        break;
                        
                    case 'change-function':
                        widgetMenu.style.display = 'block';
                        const menuRect = option.getBoundingClientRect();
                        widgetMenu.style.position = 'fixed';
                        widgetMenu.style.left = menuRect.right + 10 + 'px';
                        widgetMenu.style.top = menuRect.top + 'px';
                        widgetMenu.style.zIndex = '2000';
                        widgetMenu.dataset.replace = widgetId;
                        const firstCategory = widgetMenu.querySelector('.widget-category');
                        if (firstCategory) {
                            firstCategory.classList.add('active');
                        }
                        break;
                        
                    case 'change-avatar':
                        showVoxelAvatarSelector(widget);
                        break;
                        
                    case 'remove':
                        removeWidget(widget);
                        break;
                }
                
                // Hide context menu
                contextMenu.style.display = 'none';
            });
            
            // Page Context Menu
            // Add context menu to dashboard area
            dashboardArea.addEventListener('contextmenu', (e) => {
                // Don't show if clicking on a widget
                if (e.target.closest('.widget')) return;
                
                e.preventDefault();
                
                // Show page context menu
                pageContextMenu.style.display = 'block';
                pageContextMenu.style.left = `${e.clientX}px`;
                pageContextMenu.style.top = `${e.clientY}px`;
            });
            
            // Page Context Menu Options
            pageContextMenu.addEventListener('click', function(e) {
                const option = e.target.closest('.page-context-menu-option');
                if (!option) return;
                
                const action = option.dataset.action;
                
                switch(action) {
                    case 'change-bg':
                        // Show background settings modal
                        backgroundSettings.style.display = 'block';
                        break;
                        
                    case 'change-all-widgets':
                        // Show widget color settings modal
                        widgetColorSettings.style.display = 'block';
                        break;
                        
                    case 'toggle-all-visibility':
                        // Get all widget IDs
                        const allWidgets = document.querySelectorAll('.widget');
                        const widgetIds = Array.from(allWidgets).map(w => w.dataset.id);
                        
                        // Determine target state (public if majority are private)
                        const publicCount = Array.from(allWidgets).filter(w => w.dataset.public === 'true').length;
                        const makePublic = publicCount < allWidgets.length / 2;
                        
                        // Update all widgets
                        updateWidgetsVisibility(widgetIds, makePublic);
                        break;
                }
                
                // Hide context menu
                pageContextMenu.style.display = 'none';
            });
            
            // Function to completely reset widget active status
            function resetWidgetStatus(widgetType) {
                if (activeWidgets[widgetType]) {
                    console.log(`Resetting ${widgetType} widget status`);
                    
                    // Check if the widget actually exists in the DOM
                    const widgetElement = document.querySelector(`.${widgetType}-widget`);
                    if (!widgetElement) {
                        // Widget is marked as active but doesn't exist in DOM - reset the flag
                        activeWidgets[widgetType] = false;
                        console.log(`${widgetType} widget status was incorrectly set to active. Fixed.`);
                        return true;
                    }
                }
                return false;
            }
            
            // Remove widget function
            const removeWidget = (widget) => {
                const widgetType = widget.dataset.type;
                
                // Check for any intervals that need to be cleared
                const clockElement = widget.querySelector('[data-interval-id]');
                if (clockElement) {
                    clearInterval(parseInt(clockElement.dataset.intervalId));
                }
                
                // Clear any widget-specific intervals
                const spotifyContent = widget.querySelector('.widget-content');
                if (spotifyContent) {
                    const progressInterval = spotifyContent.dataset.progressIntervalId;
                    const refreshInterval = spotifyContent.dataset.refreshIntervalId;
                    if (progressInterval) clearInterval(parseInt(progressInterval));
                    if (refreshInterval) clearInterval(parseInt(refreshInterval));
                    
                    // Clear virtual pet intervals
                    const animInterval = spotifyContent.dataset.animationIntervalId;
                    const decreaseInterval = spotifyContent.dataset.decreaseIntervalId;
                    if (animInterval) clearInterval(parseInt(animInterval));
                    if (decreaseInterval) clearInterval(parseInt(decreaseInterval));
                    
                    // Clear alarm intervals
                    const clockUpdateInterval = spotifyContent.dataset.clockIntervalId;
                    const alarmCheckInterval = spotifyContent.dataset.alarmIntervalId;
                    if (clockUpdateInterval) clearInterval(parseInt(clockUpdateInterval));
                    if (alarmCheckInterval) clearInterval(parseInt(alarmCheckInterval));
                }
                
                // Get widget ID
                const widgetId = widget.dataset.id;
                
                // Remove widget from DOM
                widget.remove();
                
                // Reset widget availability (except for notes and image widgets)
                if (widgetType !== 'notes' && widgetType !== 'image') {
                    activeWidgets[widgetType] = false;
                    console.log(`${widgetType} widget marked as inactive`);
                }
                
                // Delete from database
                fetch('/delete-widget', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        widget_type: widgetType,
                        widget_id: widgetId
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log(`${widgetType} widget deleted from database`);
                    } else {
                        console.error(`Failed to delete ${widgetType} widget from database:`, data.message);
                    }
                })
                .catch(error => {
                    console.error('Error deleting widget from database:', error);
                });
            };
            
            // Initialize Pixel Heart
            createPixelHeart();

            // Widget Category Toggle
            document.querySelectorAll('.widget-category-header').forEach(header => {
                header.addEventListener('click', () => {
                    const category = header.closest('.widget-category');
                    category.classList.toggle('active');
                });
            });

            // Add Widget Button Click Event
            addWidgetBtn.addEventListener('click', () => {
                // First activate the first category
                const firstCategory = document.querySelector('.widget-category');
                if (firstCategory) {
                    firstCategory.classList.add('active');
                }
                
                // Verify all widget states by checking DOM
                for (const type in activeWidgets) {
                    resetWidgetStatus(type);
                }
                
                widgetMenu.style.display = widgetMenu.style.display === 'block' ? 'none' : 'block';
            });

            // Widget Option Click Event
            document.querySelectorAll('.widget-option').forEach(option => {
                option.addEventListener('click', () => {
                    const widgetType = option.dataset.widget;
                    const replaceWidgetId = widgetMenu.dataset.replace;
                    
                    // If we're replacing a widget
                    if (replaceWidgetId) {
                        const oldWidget = document.querySelector(`[data-id="${replaceWidgetId}"]`);
                        
                        if (oldWidget) {
                            // Get position of old widget
                            const left = parseInt(oldWidget.style.left) || 0;
                            const top = parseInt(oldWidget.style.top) || 0;
                            
                            // Get old widget type
                            const oldWidgetType = oldWidget.dataset.type;
                            
                            // Remove old widget
                            removeWidget(oldWidget);
                            
                            // If not replacing with same type of widget, reset the old widget type availability
                            if (oldWidgetType !== widgetType && oldWidgetType !== 'notes' && oldWidgetType !== 'image') {
                                activeWidgets[oldWidgetType] = false;
                            }
                            
                            // Create new widget at same position
                            createWidget(widgetType, left, top);
                            
                            // Clear replacement data
                            widgetMenu.dataset.replace = '';
                        }
                    } else {
                        // Regular widget creation (from add button)
                        const dashboardRect = dashboardArea.getBoundingClientRect();
                        const x = dashboardRect.width / 2 - 125;
                        const y = dashboardRect.height / 2 - 90;
                        
                        createWidget(widgetType, x, y);
                    }
                    
                    // Hide widget menu
                    widgetMenu.style.display = 'none';
                });
            });

            // Close menus when clicking outside
            document.addEventListener('click', (e) => {
                // Don't close if clicking on the add button or inside widget menu
                if (e.target === addWidgetBtn || widgetMenu.contains(e.target)) {
                    return;
                }
                
                // Close widget menu
                widgetMenu.style.display = 'none';
                
                // Close context menu if not clicking inside
                if (!contextMenu.contains(e.target)) {
                    contextMenu.style.display = 'none';
                }
                
                // Close page context menu if not clicking inside
                if (!pageContextMenu.contains(e.target)) {
                    pageContextMenu.style.display = 'none';
                }
                
                // Close color picker if not clicking inside
                if (!colorPicker.contains(e.target)) {
                    colorPicker.style.display = 'none';
                }
            });

            // Prevent normal context menu on widgets
            dashboardArea.addEventListener('contextmenu', (e) => {
                if (e.target.closest('.widget')) {
                    e.preventDefault();
                }
            });

            // Load dashboard settings
            // Load dashboard settings
            // Load dashboard settings
            const loadDashboardSettings = () => {
                const settings = userData.dashboard_settings;
                if (settings) {
                    if (settings.background_type === 'color') {
                        dashboardArea.style.backgroundImage = 'none';
                        dashboardArea.style.backgroundColor = settings.background_value || '#000000';
                    } else if (settings.background_type === 'image') {
                        dashboardArea.style.backgroundColor = 'transparent';
                        // Fix: Properly format the URL if it doesn't already start with 'url('
                        const bgValue = settings.background_value || '';
                        if (bgValue && !bgValue.startsWith('url(')) {
                            dashboardArea.style.backgroundImage = `url(${bgValue})`;
                        } else {
                            dashboardArea.style.backgroundImage = bgValue;
                        }
                    }
                }
            };

            // Load widgets
            // Load widgets
            const fetchSavedWidgets = () => {
                fetch('/get-widgets')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.widgets && data.widgets.length > 0) {
                            console.log("Fetched widgets:", data.widgets);
                            data.widgets.forEach(widget => {
                                // When creating a widget from saved data, pass the widget ID
                                createWidget(
                                    widget.widget_type,
                                    widget.position.x,
                                    widget.position.y,
                                    {
                                        widgetId: widget._id, // Pass the actual widget ID from the database
                                        width: `${widget.size.width}px`,
                                        height: `${widget.size.height}px`,
                                        bgColor: widget.bg_color,
                                        textColor: widget.text_color,
                                        content: widget.content,
                                        isPublic: widget.is_public
                                    }
                                );
                            });
                        } else {
                            // Create default widgets if no saved widgets
                            createDefaultWidgets();
                        }
                        
                        // Load dashboard settings
                        loadDashboardSettings();
                        
                        // Hide loading screen
                        loadingScreen.style.display = 'none';
                    })
                    .catch(error => {
                        console.error('Error fetching widgets:', error);
                        // Create default widgets on error
                        createDefaultWidgets();
                        
                        // Hide loading screen
                        loadingScreen.style.display = 'none';
                    });
            };

            // Create default widgets
            const createDefaultWidgets = () => {
                createWidget('profile', 50, 50);
                createWidget('skills', 380, 50);
                createWidget('streak', 50, 280);
                createWidget('calendar', 380, 280); // Add calendar as a default widget
                createWidget('todo', 50, 480); // Add todo list as a default widget
                
                // If user has GitHub username, create GitHub widget
                if (userData.github_username) {
                    createWidget('github', 710, 50);
                }
            };

            // Start loading widgets
            loadingScreen.style.display = 'block';
            fetchSavedWidgets();

            // Tutorial System
            function initTutorial() {
                // Check if user is first-time visitor
                const hasSeenTutorial = localStorage.getItem('hasSeenTutorial');
                
                if (!hasSeenTutorial) {
                    // Wait for dashboard to load
                    setTimeout(() => startTutorial(), 1000);
                }
            }

            // Define tutorial steps with character states
            const tutorialSteps = [
                {
                    text: "Welcome to INK! I'll show you around this dashboard. Click Next to continue.",
                    element: null,
                    position: { bubble: { left: '50%', top: '50%' } },
                    characterState: "normal" // normal state
                },
                {
                    text: "This is the Add Widget button. Click it to add new widgets to your dashboard.",
                    element: "#addWidgetBtn",
                    position: { bubble: { right: '200px', bottom: '100px' } },
                    characterState: "explaining" // explaining state
                },
                {
                    text: "Right-click on any widget to open a menu with options like changing colors or removing the widget.",
                    element: ".widget",
                    position: { bubble: { left: '400px', top: '200px' } },
                    characterState: "explaining" // explaining state
                },
                {
                    text: "You can drag widgets around to organize your dashboard however you like.",
                    element: ".widget-header",
                    position: { bubble: { left: '300px', top: '150px' } },
                    characterState: "explaining" // explaining state
                },
                {
                    text: "You can resize widgets by dragging the bottom-right corner.",
                    element: ".resize-handle",
                    position: { bubble: { right: '300px', bottom: '200px' } },
                    characterState: "explaining" // explaining state
                },
                {
                    text: "We've added new features like Calendar, To-Do List, Pomodoro Timer, Virtual Pet, and Alarm widgets, as well as image widgets and custom backgrounds.",
                    element: null,
                    position: { bubble: { left: '50%', top: '50%' } },
                    characterState: "excited" // excited state
                },
                {
                    text: "Try right-clicking on the dashboard background to access page-level settings. You can change the dashboard background or update all widgets at once.",
                    element: "#dashboardArea",
                    position: { bubble: { left: '50%', top: '50%' } },
                    characterState: "explaining" // explaining state
                },
                {
                    text: "You can also make widgets public or private! Private widgets are only visible to you, while public ones can be seen by visitors to your profile.",
                    element: null,
                    position: { bubble: { left: '50%', top: '50%' } },
                    characterState: "explaining" // explaining state
                },
                {
                    text: "That's it! Enjoy your personalized INK dashboard.",
                    element: null,
                    position: { bubble: { left: '50%', top: '50%' } },
                    characterState: "excited" // excited state
                }
            ];

            let currentStep = 0;

            function startTutorial() {
                // Create tutorial overlay if it doesn't exist
                if (!document.getElementById('tutorialOverlay')) {
                    const overlay = document.createElement('div');
                    overlay.id = 'tutorialOverlay';
                    overlay.className = 'tutorial-overlay';
                    
                    const bubbleContainer = document.createElement('div');
                    bubbleContainer.className = 'tutorial-bubble-container';
                    
                    const bubble = document.createElement('div');
                    bubble.className = 'tutorial-bubble';
                    
                    const character = document.createElement('div');
                    character.className = 'tutorial-character';
                    character.innerHTML = '<img id="tutorialCharacter" src="/static/assets/tutorial-sprite-normal.png" alt="Tutorial Guide">';
                    
                    const textContainer = document.createElement('div');
                    textContainer.className = 'tutorial-text-container';
                    textContainer.innerHTML = `
                        <p id="tutorialText">Welcome to INK! I'll show you around this dashboard. Click Next to continue.</p>
                        <div class="tutorial-buttons">
                            <button id="tutorialSkipBtn">Skip</button>
                            <button id="tutorialNextBtn">Next</button>
                        </div>
                    `;
                    
                    bubble.appendChild(character);
                    bubble.appendChild(textContainer);
                    bubbleContainer.appendChild(bubble);
                    
                    const highlight = document.createElement('div');
                    highlight.id = 'tutorialHighlight';
                    highlight.className = 'tutorial-highlight';
                    
                    overlay.appendChild(bubbleContainer);
                    overlay.appendChild(highlight);
                    
                    document.body.appendChild(overlay);
                }
                
                const tutorialOverlay = document.getElementById('tutorialOverlay');
                const tutorialNextBtn = document.getElementById('tutorialNextBtn');
                const tutorialSkipBtn = document.getElementById('tutorialSkipBtn');
                
                tutorialOverlay.style.display = 'block';
                
                // Set up button event listeners
                tutorialNextBtn.addEventListener('click', nextTutorialStep);
                tutorialSkipBtn.addEventListener('click', endTutorial);
                
                // Start with first step
                showTutorialStep(currentStep);
            }

            function showTutorialStep(stepIndex) {
                const step = tutorialSteps[stepIndex];
                const tutorialCharacter = document.getElementById('tutorialCharacter');
                const tutorialBubbleContainer = document.querySelector('.tutorial-bubble-container');
                const tutorialText = document.getElementById('tutorialText');
                const tutorialHighlight = document.getElementById('tutorialHighlight');
                
                // Update text
                tutorialText.textContent = step.text;
                
                // Position bubble container
                for (const [prop, value] of Object.entries(step.position.bubble)) {
                    tutorialBubbleContainer.style[prop] = value;
                }
                
                // Set character state
                switch(step.characterState) {
                    case "normal":
                        tutorialCharacter.src = "/static/assets/tutorial-sprite-normal.png";
                        break;
                    case "excited":
                        tutorialCharacter.src = "/static/assets/tutorial-sprite-excited.png";
                        break;
                    case "explaining":
                        tutorialCharacter.src = "/static/assets/tutorial-sprite-explaining.png";
                        break;
                }
                
                // Reset highlight
                tutorialHighlight.style.display = 'none';
                
                // Add highlight if needed
                if (step.element) {
                    const targetElement = document.querySelector(step.element);
                    if (targetElement) {
                        const rect = targetElement.getBoundingClientRect();
                        tutorialHighlight.style.display = 'block';
                        tutorialHighlight.style.left = `${rect.left - 5}px`;
                        tutorialHighlight.style.top = `${rect.top - 5}px`;
                        tutorialHighlight.style.width = `${rect.width + 10}px`;
                        tutorialHighlight.style.height = `${rect.height + 10}px`;
                    }
                }
                
                // Show/hide next button on last step
                const nextBtn = document.getElementById('tutorialNextBtn');
                if (stepIndex === tutorialSteps.length - 1) {
                    nextBtn.textContent = 'Finish';
                } else {
                    nextBtn.textContent = 'Next';
                }
            }

            function nextTutorialStep() {
                currentStep++;
                
                if (currentStep >= tutorialSteps.length) {
                    endTutorial();
                    return;
                }
                
                showTutorialStep(currentStep);
            }

            function endTutorial() {
                // Mark tutorial as seen
                localStorage.setItem('hasSeenTutorial', 'true');
                
                // Hide tutorial
                const tutorialOverlay = document.getElementById('tutorialOverlay');
                tutorialOverlay.style.display = 'none';
            }

            // Start tutorial after dashboard is loaded
            initTutorial();
        });
    </script>
    
    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" class="tutorial-overlay" style="display:none;">
        <div class="tutorial-bubble-container">
            <div class="tutorial-bubble">
                <div class="tutorial-character">
                    <img id="tutorialCharacter" src="/static/assets/tutorial-sprite-normal.png" alt="Tutorial Guide">
                </div>
                <div class="tutorial-text-container">
                    <p id="tutorialText">Welcome to INK! I'll show you around this dashboard. Click Next to continue.</p>
                    <div class="tutorial-buttons">
                        <button id="tutorialSkipBtn">Skip</button>
                        <button id="tutorialNextBtn">Next</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="tutorialHighlight" class="tutorial-highlight"></div>
    </div>
</body>
</html>